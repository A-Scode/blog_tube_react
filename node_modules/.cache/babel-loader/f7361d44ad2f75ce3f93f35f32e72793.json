{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar createContext = _interopDefault(require('mini-create-react-context'));\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar reactRouterDom = require('react-router-dom'); // 值类型判断 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nvar isUndefined = function isUndefined(val) {\n  return typeof val === 'undefined';\n};\n\nvar isNull = function isNull(val) {\n  return val === null;\n};\n\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\n\nvar isString = function isString(val) {\n  return typeof val === 'string';\n};\n\nvar isExist = function isExist(val) {\n  return !(isUndefined(val) || isNull(val));\n};\n\nvar isArray = function isArray(val) {\n  return val instanceof Array;\n};\n\nvar isNaN = function isNaN(val) {\n  return val !== val;\n};\n\nvar isNumber = function isNumber(val) {\n  return typeof val === 'number' && !isNaN(val);\n}; // 值类型判断 -------------------------------------------------------------\n\n\nvar get = function get(obj) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var defaultValue = arguments[2];\n\n  try {\n    if (isNumber(keys)) {\n      keys = String(keys);\n    }\n\n    var result = (isString(keys) ? keys.split('.') : keys).reduce(function (res, key) {\n      return res[key];\n    }, obj);\n    return isUndefined(result) ? defaultValue : result;\n  } catch (e) {\n    return defaultValue;\n  }\n};\n\nvar run = function run(obj) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  keys = isString(keys) ? keys.split('.') : keys;\n  var func = get(obj, keys);\n  var context = get(obj, keys.slice(0, -1));\n  return isFunction(func) ? func.call.apply(func, [context].concat(args)) : func;\n};\n\nvar value = function value() {\n  for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    values[_key2] = arguments[_key2];\n  }\n\n  return values.reduce(function (value, nextValue) {\n    return isUndefined(value) ? run(nextValue) : run(value);\n  }, undefined);\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar getImplementation = function getImplementation() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  throw new Error('unable to locate global object');\n};\n\nvar implementation = getImplementation();\n\nvar getGlobal = function getGlobal() {\n  if ((typeof global === 'undefined' ? 'undefined' : _typeof(global)) !== 'object' || !global || global.Math !== Math || global.Array !== Array) {\n    return implementation;\n  }\n\n  return global;\n};\n\nvar globalThis = getGlobal();\n\nvar flatten = function flatten(array) {\n  return array.reduce(function (res, item) {\n    return [].concat(toConsumableArray(res), toConsumableArray(isArray(item) ? flatten(item) : [item]));\n  }, []);\n};\n/**\n * [钳子] 用来将数字限制在给定范围内\n * @param {Number} value 被限制值\n * @param {Number} min 最小值\n * @param {Number} max 最大值\n */\n\n\nvar clamp = function clamp(value, min) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n\n  if (value < min) {\n    return min;\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  return value;\n};\n\nvar ObjectValues = function ObjectValues(object) {\n  var res = [];\n\n  for (var key in object) {\n    res.push(object[key]);\n  }\n\n  return res;\n};\n\nvar body = get(globalThis, 'document.body');\nvar screenScrollingElement = get(globalThis, 'document.scrollingElement', get(globalThis, 'document.documentElement', {}));\n\nfunction isScrollableNode() {\n  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!isExist(node)) {\n    return false;\n  }\n\n  return node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight;\n}\n\nfunction getScrollableNodes(from) {\n  if (!isFunction(get(globalThis, 'document.getElementById'))) {\n    return [];\n  }\n\n  return [].concat(toConsumableArray(value(run(from, 'querySelectorAll', '*'), [])), [from]).filter(isScrollableNode);\n}\n\nfunction saveScrollPosition(from) {\n  var nodes = [].concat(toConsumableArray(new Set([].concat(toConsumableArray(flatten((!isArray(from) ? [from] : from).map(getScrollableNodes))), toConsumableArray([screenScrollingElement, body].filter(isScrollableNode))))));\n  var saver = nodes.map(function (node) {\n    return [node, {\n      x: node.scrollLeft,\n      y: node.scrollTop\n    }];\n  });\n  return function revert() {\n    saver.forEach(function (_ref) {\n      var _ref2 = slicedToArray(_ref, 2),\n          node = _ref2[0],\n          _ref2$ = _ref2[1],\n          x = _ref2$.x,\n          y = _ref2$.y;\n\n      node.scrollLeft = x;\n      node.scrollTop = y;\n    });\n  };\n}\n\nvar __components = {};\n\nvar getCachedComponentEntries = function getCachedComponentEntries() {\n  return Object.entries(__components).filter(function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        cache = _ref2[1];\n\n    return cache instanceof CacheComponent ? cache.state.cached : Object.values(cache).some(function (cache) {\n      return cache.state.cached;\n    });\n  });\n};\n\nvar getCache = function getCache() {\n  return _extends({}, __components);\n};\n\nvar register = function register(key, component) {\n  __components[key] = component;\n};\n\nvar remove = function remove(key) {\n  delete __components[key];\n};\n\nvar dropComponent = function dropComponent(component) {\n  return run(component, 'reset');\n};\n\nvar dropByCacheKey = function dropByCacheKey(key) {\n  var cache = get(__components, [key]);\n\n  if (!cache) {\n    return;\n  }\n\n  if (cache instanceof CacheComponent) {\n    dropComponent(cache);\n  } else {\n    Object.values(cache).forEach(dropComponent);\n  }\n};\n\nvar refreshComponent = function refreshComponent(component) {\n  return run(component, 'refresh');\n};\n\nvar refreshByCacheKey = function refreshByCacheKey(key) {\n  var cache = get(__components, [key]);\n\n  if (!cache) {\n    return;\n  }\n\n  if (cache instanceof CacheComponent) {\n    refreshComponent(cache);\n  } else {\n    Object.values(cache).forEach(refreshComponent);\n  }\n};\n\nvar clearCache = function clearCache() {\n  getCachedComponentEntries().forEach(function (_ref3) {\n    var _ref4 = slicedToArray(_ref3, 1),\n        key = _ref4[0];\n\n    return dropByCacheKey(key);\n  });\n};\n\nvar getCachingKeys = function getCachingKeys() {\n  return getCachedComponentEntries().map(function (_ref5) {\n    var _ref6 = slicedToArray(_ref5, 1),\n        key = _ref6[0];\n\n    return key;\n  });\n};\n\nvar getCachingComponents = function getCachingComponents() {\n  return getCachedComponentEntries().reduce(function (res, _ref7) {\n    var _ref8 = slicedToArray(_ref7, 2),\n        key = _ref8[0],\n        cache = _ref8[1];\n\n    return _extends({}, res, cache instanceof CacheComponent ? defineProperty({}, key, cache) : Object.entries(cache).reduce(function (res, _ref10) {\n      var _ref11 = slicedToArray(_ref10, 2),\n          pathname = _ref11[0],\n          cache = _ref11[1];\n\n      return _extends({}, res, defineProperty({}, key + '.' + pathname, cache));\n    }, {}));\n  }, {});\n};\n\nvar context = createContext();\nvar Provider = context.Provider,\n    Consumer = context.Consumer;\n\nfunction useCacheRoute(lifecycleName, effect) {\n  var deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (!isFunction(React.useContext)) {\n    return;\n  }\n\n  var cacheLifecycles = React.useContext(context);\n  React.useEffect(function () {\n    var off = run(cacheLifecycles, 'on', lifecycleName, effect);\n    return function () {\n      return run(off);\n    };\n  }, deps);\n}\n\nvar useDidCache = useCacheRoute.bind(null, 'didCache');\nvar useDidRecover = useCacheRoute.bind(null, 'didRecover');\nvar isUsingNewLifecycle = isExist(React__default.forwardRef);\nvar COMPUTED_UNMATCH_KEY = '__isComputedUnmatch';\n\nvar isMatch = function isMatch(match) {\n  return isExist(match) && get(match, COMPUTED_UNMATCH_KEY) !== true;\n};\n\nvar getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n  var nextPropsMatch = nextProps.match,\n      _nextProps$when = nextProps.when,\n      when = _nextProps$when === undefined ? 'forward' : _nextProps$when;\n  /**\r\n   * Note:\r\n   * Turn computedMatch from CacheSwitch to a real null value\r\n   *\r\n   * 将 CacheSwitch 计算得到的 computedMatch 值转换为真正的 null\r\n   */\n\n  if (!isMatch(nextPropsMatch)) {\n    nextPropsMatch = null;\n  }\n\n  if (!prevState.cached && nextPropsMatch) {\n    return {\n      cached: true,\n      matched: true\n    };\n  }\n  /**\r\n   * Determines whether it needs to cancel the cache based on the next unmatched props action\r\n   *\r\n   * 根据下个未匹配状态动作决定是否需要取消缓存\r\n   */\n\n\n  if (prevState.matched && !nextPropsMatch) {\n    var nextAction = get(nextProps, 'history.action');\n    var __cancel__cache = false;\n\n    if (isFunction(when)) {\n      __cancel__cache = !when(nextProps);\n    } else {\n      switch (when) {\n        case 'always':\n          break;\n\n        case 'back':\n          if (['PUSH', 'REPLACE'].includes(nextAction)) {\n            __cancel__cache = true;\n          }\n\n          break;\n\n        case 'forward':\n        default:\n          if (nextAction === 'POP') {\n            __cancel__cache = true;\n          }\n\n      }\n    }\n\n    if (__cancel__cache) {\n      return {\n        cached: false,\n        matched: false\n      };\n    }\n  }\n\n  return {\n    matched: !!nextPropsMatch\n  };\n};\n\nvar CacheComponent = function (_Component) {\n  inherits(CacheComponent, _Component);\n\n  function CacheComponent(props) {\n    var _ref;\n\n    classCallCheck(this, CacheComponent);\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var _this = possibleConstructorReturn(this, (_ref = CacheComponent.__proto__ || Object.getPrototypeOf(CacheComponent)).call.apply(_ref, [this, props].concat(args)));\n\n    _this.cacheLifecycles = {\n      __listener: {},\n      __didCacheListener: {},\n      __didRecoverListener: {},\n      on: function on(eventName, func) {\n        var id = Math.random();\n        var listenerKey = '__' + eventName + 'Listener';\n        _this.cacheLifecycles[listenerKey][id] = func;\n        return function () {\n          delete _this.cacheLifecycles[listenerKey][id];\n        };\n      },\n      didCache: function didCache(listener) {\n        _this.cacheLifecycles.__listener['didCache'] = listener;\n      },\n      didRecover: function didRecover(listener) {\n        _this.cacheLifecycles.__listener['didRecover'] = listener;\n      }\n      /**\r\n       * New lifecycle for replacing the `componentWillReceiveProps` in React 16.3 +\r\n       * React 16.3 + 版本中替代 componentWillReceiveProps 的新生命周期\r\n       */\n\n    };\n    _this.componentWillReceiveProps = !isUsingNewLifecycle ? function (nextProps) {\n      var nextState = getDerivedStateFromProps(nextProps, _this.state);\n\n      _this.setState(nextState);\n    } : undefined;\n\n    _this.injectDOM = function () {\n      try {\n        run(_this.__parentNode, 'insertBefore', _this.wrapper, _this.__placeholderNode);\n        run(_this.__parentNode, 'removeChild', _this.__placeholderNode);\n      } catch (err) {// nothing\n      }\n    };\n\n    _this.ejectDOM = function () {\n      try {\n        var parentNode = get(_this.wrapper, 'parentNode');\n        _this.__parentNode = parentNode;\n        run(_this.__parentNode, 'insertBefore', _this.__placeholderNode, _this.wrapper);\n        run(_this.__parentNode, 'removeChild', _this.wrapper);\n      } catch (err) {// nothing\n      }\n    };\n\n    _this.reset = function () {\n      delete _this.__revertScrollPos;\n\n      _this.setState({\n        cached: false\n      });\n    };\n\n    _this.refresh = function () {\n      delete _this.__revertScrollPos;\n\n      _this.setState({\n        key: Math.random()\n      });\n    };\n\n    _this.__cacheCreateTime = Date.now();\n    _this.__cacheUpdateTime = _this.__cacheCreateTime;\n\n    if (props.cacheKey) {\n      var cacheKey = run(props.cacheKey, undefined, props);\n\n      if (props.multiple) {\n        var pathname = props.pathname;\n        register(cacheKey, _extends({}, getCache()[cacheKey], defineProperty({}, pathname, _this)));\n      } else {\n        register(cacheKey, _this);\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      var _cacheKey = run(props.cacheKey, undefined, props);\n\n      _this.__placeholderNode = document.createComment(' Route cached ' + (_cacheKey ? 'with cacheKey: \"' + _cacheKey + '\" ' : ''));\n    }\n\n    _this.state = getDerivedStateFromProps(props, {\n      cached: false,\n      matched: false,\n      key: Math.random()\n    });\n    return _this;\n  }\n  /**\r\n   * Compatible React 16.3 -\r\n   * 兼容 React 16.3 - 版本\r\n   */\n\n\n  createClass(CacheComponent, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (!prevState.cached || !this.state.cached) {\n        return;\n      }\n\n      if (prevState.matched === true && this.state.matched === false) {\n        if (this.props.unmount) {\n          this.ejectDOM();\n        }\n\n        this.__cacheUpdateTime = Date.now();\n        ObjectValues(this.cacheLifecycles.__didCacheListener).forEach(function (func) {\n          run(func);\n        });\n        return run(this, 'cacheLifecycles.__listener.didCache');\n      }\n\n      if (prevState.matched === false && this.state.matched === true) {\n        if (this.props.saveScrollPosition) {\n          run(this.__revertScrollPos);\n        }\n\n        this.__cacheUpdateTime = Date.now();\n        ObjectValues(this.cacheLifecycles.__didRecoverListener).forEach(function (func) {\n          run(func);\n        });\n        return run(this, 'cacheLifecycles.__listener.didRecover');\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var willRecover = this.state.matched === false && nextState.matched === true;\n      var willDrop = this.state.cached === true && nextState.cached === false;\n      var shouldUpdate = this.state.matched || nextState.matched || this.state.cached !== nextState.cached;\n\n      if (shouldUpdate) {\n        if (this.props.unmount && willDrop || willRecover) {\n          this.injectDOM();\n        }\n\n        if (!(willDrop || willRecover) && this.props.saveScrollPosition) {\n          this.__revertScrollPos = saveScrollPosition(this.props.unmount ? this.wrapper : undefined);\n        }\n      }\n\n      return shouldUpdate;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _props = this.props,\n          unmount = _props.unmount,\n          pathname = _props.pathname,\n          multiple = _props.multiple;\n      var cacheKey = run(this.props, 'cacheKey', this.props);\n\n      if (multiple) {\n        var cache = _extends({}, getCache()[cacheKey]);\n\n        delete cache[pathname];\n\n        if (Object.keys(cache).length === 0) {\n          remove(cacheKey);\n        } else {\n          register(cacheKey, cache);\n        }\n      } else {\n        remove(cacheKey);\n      }\n\n      if (unmount) {\n        this.injectDOM();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _state = this.state,\n          matched = _state.matched,\n          cached = _state.cached,\n          key = _state.key;\n      var _props2 = this.props,\n          _props2$className = _props2.className,\n          propsClassName = _props2$className === undefined ? '' : _props2$className,\n          behavior = _props2.behavior,\n          children = _props2.children;\n\n      var _value = value(run(behavior, undefined, !matched), {}),\n          _value$className = _value.className,\n          behaviorClassName = _value$className === undefined ? '' : _value$className,\n          behaviorProps = objectWithoutProperties(_value, ['className']);\n\n      var className = run(propsClassName + ' ' + behaviorClassName, 'trim');\n      var hasClassName = className !== '';\n      return cached ? React__default.createElement('div', _extends({\n        key: key,\n        className: hasClassName ? className : undefined\n      }, behaviorProps, {\n        ref: function ref(wrapper) {\n          _this2.wrapper = wrapper;\n        }\n      }), React__default.createElement(Provider, {\n        value: this.cacheLifecycles\n      }, run(children, undefined, this.cacheLifecycles))) : null;\n    }\n  }]);\n  return CacheComponent;\n}(React.Component);\n\nCacheComponent.__name = 'CacheComponent';\nCacheComponent.propsTypes = {\n  history: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  children: PropTypes.func.isRequired,\n  className: PropTypes.string,\n  when: PropTypes.oneOfType([PropTypes.func, PropTypes.oneOf(['forward', 'back', 'always'])]),\n  behavior: PropTypes.func,\n  unmount: PropTypes.bool,\n  saveScrollPosition: PropTypes.bool\n};\nCacheComponent.defaultProps = {\n  when: 'forward',\n  unmount: false,\n  saveScrollPosition: false,\n  behavior: function behavior(cached) {\n    return cached ? {\n      style: {\n        display: 'none'\n      }\n    } : undefined;\n  }\n};\nCacheComponent.getDerivedStateFromProps = isUsingNewLifecycle ? getDerivedStateFromProps : undefined;\n\nvar Updatable = function (_Component) {\n  inherits(Updatable, _Component);\n\n  function Updatable() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Updatable);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Updatable.__proto__ || Object.getPrototypeOf(Updatable)).call.apply(_ref, [this].concat(args))), _this), _this.render = function () {\n      return run(_this.props, 'children');\n    }, _this.shouldComponentUpdate = function (_ref2) {\n      var when = _ref2.when;\n      return when;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return Updatable;\n}(React.Component);\n\nUpdatable.propsTypes = {\n  when: PropTypes.bool.isRequired\n};\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return React__default.Children.count(children) === 0;\n};\n\nvar isFragmentable = isExist(React.Fragment);\n\nvar CacheRoute = function (_Component) {\n  inherits(CacheRoute, _Component);\n\n  function CacheRoute() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, CacheRoute);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = CacheRoute.__proto__ || Object.getPrototypeOf(CacheRoute)).call.apply(_ref, [this].concat(args))), _this), _this.cache = {}, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(CacheRoute, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          children = _props.children,\n          render = _props.render,\n          component = _props.component,\n          className = _props.className,\n          when = _props.when,\n          behavior = _props.behavior,\n          cacheKey = _props.cacheKey,\n          unmount = _props.unmount,\n          saveScrollPosition$$1 = _props.saveScrollPosition,\n          computedMatchForCacheRoute = _props.computedMatchForCacheRoute,\n          multiple = _props.multiple,\n          restProps = objectWithoutProperties(_props, ['children', 'render', 'component', 'className', 'when', 'behavior', 'cacheKey', 'unmount', 'saveScrollPosition', 'computedMatchForCacheRoute', 'multiple']);\n      /**\r\n       * Note:\r\n       * If children prop is a React Element, define the corresponding wrapper component for supporting multiple children\r\n       *\r\n       * 说明：如果 children 属性是 React Element 则定义对应的包裹组件以支持多个子组件\r\n       */\n\n      if (React__default.isValidElement(children) || !isEmptyChildren(children)) {\n        render = function render() {\n          return children;\n        };\n      }\n\n      if (computedMatchForCacheRoute) {\n        restProps.computedMatch = computedMatchForCacheRoute;\n      }\n\n      if (multiple && !isFragmentable) {\n        multiple = false;\n      }\n\n      if (isNumber(multiple)) {\n        multiple = clamp(multiple, 1);\n      }\n\n      return (\n        /**\r\n         * Only children prop of Route can help to control rendering behavior\r\n         * 只有 Router 的 children 属性有助于主动控制渲染行为\r\n         */\n        React__default.createElement(reactRouterDom.Route, restProps, function (props) {\n          var match = props.match,\n              computedMatch = props.computedMatch,\n              location = props.location;\n          var isMatchCurrentRoute = isMatch(props.match);\n          var currentPathname = location.pathname,\n              currentSearch = location.search;\n          var maxMultipleCount = isNumber(multiple) ? multiple : Infinity;\n          var configProps = {\n            when: when,\n            className: className,\n            behavior: behavior,\n            cacheKey: cacheKey,\n            unmount: unmount,\n            saveScrollPosition: saveScrollPosition$$1\n          };\n\n          var renderSingle = function renderSingle(props) {\n            return React__default.createElement(CacheComponent, props, function (cacheLifecycles) {\n              return React__default.createElement(Updatable, {\n                when: isMatch(props.match)\n              }, function () {\n                Object.assign(props, {\n                  cacheLifecycles: cacheLifecycles\n                });\n\n                if (component) {\n                  return React__default.createElement(component, props);\n                }\n\n                return run(render || children, undefined, props);\n              });\n            });\n          };\n\n          if (multiple && isMatchCurrentRoute) {\n            _this2.cache[currentPathname + currentSearch] = {\n              updateTime: Date.now(),\n              pathname: currentPathname,\n              search: currentSearch,\n              render: renderSingle\n            };\n            Object.entries(_this2.cache).sort(function (_ref2, _ref3) {\n              var _ref5 = slicedToArray(_ref2, 2),\n                  prev = _ref5[1];\n\n              var _ref4 = slicedToArray(_ref3, 2),\n                  next = _ref4[1];\n\n              return next.updateTime - prev.updateTime;\n            }).forEach(function (_ref6, idx) {\n              var _ref7 = slicedToArray(_ref6, 1),\n                  pathname = _ref7[0];\n\n              if (idx >= maxMultipleCount) {\n                delete _this2.cache[pathname];\n              }\n            });\n          }\n\n          return multiple ? React__default.createElement(React.Fragment, null, Object.entries(_this2.cache).map(function (_ref8) {\n            var _ref9 = slicedToArray(_ref8, 2),\n                multipleCacheKey = _ref9[0],\n                _ref9$ = _ref9[1],\n                render = _ref9$.render,\n                pathname = _ref9$.pathname;\n\n            var recomputedMatch = multipleCacheKey === currentPathname + currentSearch ? match || computedMatch : null;\n            return React__default.createElement(React.Fragment, {\n              key: multipleCacheKey\n            }, render(_extends({}, props, configProps, {\n              pathname: pathname,\n              cacheKey: cacheKey,\n              multiple: true,\n              key: pathname,\n              match: recomputedMatch\n            })));\n          })) : renderSingle(_extends({}, props, configProps, {\n            pathname: currentPathname,\n            multiple: false\n          }));\n        })\n      );\n    }\n  }]);\n  return CacheRoute;\n}(React.Component);\n\nCacheRoute.__name = 'CacheRoute';\nCacheRoute.propTypes = {\n  component: PropTypes.elementType || PropTypes.any,\n  render: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  computedMatchForCacheRoute: PropTypes.object,\n  multiple: PropTypes.oneOfType([PropTypes.bool, PropTypes.number])\n};\nCacheRoute.defaultProps = {\n  multiple: false\n};\n\nfunction getFragment() {\n  if (isExist(React.Fragment)) {\n    return function (_ref) {\n      var children = _ref.children;\n      return React__default.createElement(React.Fragment, null, children);\n    };\n  }\n\n  if (isExist(React.PropTypes)) {\n    return function (_ref2) {\n      var children = _ref2.children;\n      return React__default.createElement('div', null, children);\n    };\n  }\n\n  return function (_ref3) {\n    var children = _ref3.children;\n    return children;\n  };\n}\n\nvar SwitchFragment = getFragment();\nSwitchFragment.displayName = 'SwitchFragment';\nvar isUsingNewContext = isExist(reactRouterDom.__RouterContext) || isExist(reactRouterDom.useHistory);\n\nvar CacheSwitch = function (_Switch) {\n  inherits(CacheSwitch, _Switch);\n\n  function CacheSwitch() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, CacheSwitch);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = CacheSwitch.__proto__ || Object.getPrototypeOf(CacheSwitch)).call.apply(_ref, [this].concat(args))), _this), _this.getContext = function () {\n      if (isUsingNewContext) {\n        var _this$props = _this.props,\n            location = _this$props.location,\n            match = _this$props.match;\n        return {\n          location: location,\n          match: match\n        };\n      } else {\n        var route = _this.context.router.route;\n\n        var _location = _this.props.location || route.location;\n\n        return {\n          location: _location,\n          match: route.match\n        };\n      }\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(CacheSwitch, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          children = _props.children,\n          which = _props.which;\n\n      var _getContext = this.getContext(),\n          location = _getContext.location,\n          contextMatch = _getContext.match;\n\n      var __matchedAlready = false;\n      return React__default.createElement(Updatable, {\n        when: isMatch(contextMatch)\n      }, function () {\n        return React__default.createElement(SwitchFragment, null, React__default.Children.map(children, function (element) {\n          if (!React__default.isValidElement(element)) {\n            return null;\n          }\n\n          var path = element.props.path || element.props.from;\n          var match = __matchedAlready ? null : path ? reactRouterDom.matchPath(location.pathname, _extends({}, element.props, {\n            path: path\n          }), contextMatch) : contextMatch;\n          var child = void 0;\n\n          if (which(element)) {\n            child = React__default.cloneElement(element, _extends({\n              location: location,\n              computedMatch: match\n            }, isNull(match) ? {\n              computedMatchForCacheRoute: defineProperty({}, COMPUTED_UNMATCH_KEY, true)\n            } : null));\n          } else {\n            child = match && !__matchedAlready ? React__default.cloneElement(element, {\n              location: location,\n              computedMatch: match\n            }) : null;\n          }\n\n          if (!__matchedAlready) {\n            __matchedAlready = !!match;\n          }\n\n          return child;\n        }));\n      });\n    }\n  }]);\n  return CacheSwitch;\n}(reactRouterDom.Switch);\n\nif (isUsingNewContext) {\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object.isRequired,\n    match: PropTypes.object.isRequired,\n    which: PropTypes.func\n  };\n  CacheSwitch = reactRouterDom.withRouter(CacheSwitch);\n} else {\n  CacheSwitch.contextTypes = {\n    router: PropTypes.shape({\n      route: PropTypes.object.isRequired\n    }).isRequired\n  };\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object,\n    which: PropTypes.func\n  };\n}\n\nCacheSwitch.defaultProps = {\n  which: function which(element) {\n    return get(element, 'type.__name') === 'CacheRoute';\n  }\n};\nvar CacheSwitch$1 = CacheSwitch;\nexports.default = CacheRoute;\nexports.CacheRoute = CacheRoute;\nexports.CacheSwitch = CacheSwitch$1;\nexports.dropByCacheKey = dropByCacheKey;\nexports.refreshByCacheKey = refreshByCacheKey;\nexports.getCachingKeys = getCachingKeys;\nexports.clearCache = clearCache;\nexports.getCachingComponents = getCachingComponents;\nexports.useDidCache = useDidCache;\nexports.useDidRecover = useDidRecover;","map":{"version":3,"sources":["../src/helpers/base/is.js","../src/helpers/base/try/index.js","../src/helpers/base/globalThis.js","../src/helpers/utils.js","../src/helpers/saveScrollPosition.js","../src/core/manager.js","../src/core/context.js","../src/core/CacheComponent.js","../src/core/Updatable.js","../src/components/CacheRoute.js","../src/components/SwitchFragment.js","../src/components/CacheSwitch.js"],"names":["isUndefined","isNull","val","isFunction","isString","isExist","isArray","isNaN","isNumber","get","keys","defaultValue","String","result","res","run","args","func","context","value","values","getImplementation","implementation","getGlobal","global","globalThis","flatten","clamp","max","Number","MAX_VALUE","ObjectValues","object","body","screenScrollingElement","node","nodes","saver","scrollTop","x","y","__components","getCachedComponentEntries","cache","getCache","register","remove","dropComponent","dropByCacheKey","refreshComponent","refreshByCacheKey","clearCache","key","getCachingKeys","getCachingComponents","pathname","createContext","Provider","Consumer","deps","useContext","cacheLifecycles","off","useDidCache","useCacheRoute","useDidRecover","isUsingNewLifecycle","React","COMPUTED_UNMATCH_KEY","isMatch","getDerivedStateFromProps","nextPropsMatch","when","nextProps","prevState","nextAction","__cancel__cache","CacheComponent","Component","__name","propsTypes","PropTypes","bool","defaultProps","Date","props","cacheKey","manager","document","Math","id","listenerKey","undefined","nextState","parentNode","prevProps","willRecover","willDrop","shouldUpdate","saveScrollPosition","unmount","multiple","Object","matched","cached","propsClassName","behavior","children","behaviorClassName","behaviorProps","className","hasClassName","Updatable","isRequired","render","shouldComponentUpdate","isEmptyChildren","isFragmentable","Fragment","CacheRoute","propTypes","component","computedMatchForCacheRoute","restProps","match","computedMatch","location","isMatchCurrentRoute","currentPathname","currentSearch","maxMultipleCount","configProps","renderSingle","prev","next","idx","multipleCacheKey","recomputedMatch","SwitchFragment","getFragment","isUsingNewContext","__RouterContext","useHistory","CacheSwitch","Switch","getContext","route","which","contextMatch","__matchedAlready","path","element","child","withRouter"],"mappings":"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","sourcesContent":["// 值类型判断 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nexport const isUndefined = val => typeof val === 'undefined'\n\nexport const isNull = val => val === null\n\nexport const isFunction = val => typeof val === 'function'\n\nexport const isString = val => typeof val === 'string'\n\nexport const isExist = val => !(isUndefined(val) || isNull(val))\n\nexport const isArray = val => val instanceof Array\n\nexport const isNaN = val => val !== val\n\nexport const isNumber = val => typeof val === 'number' && !isNaN(val)\n// 值类型判断 -------------------------------------------------------------\n","import { isString, isExist, isUndefined, isFunction, isNumber } from '../is'\n\nexport const get = (obj, keys = [], defaultValue) => {\n  try {\n    if (isNumber(keys)) {\n      keys = String(keys)\n    }\n    let result = (isString(keys) ? keys.split('.') : keys).reduce(\n      (res, key) => res[key],\n      obj\n    )\n    return isUndefined(result) ? defaultValue : result\n  } catch (e) {\n    return defaultValue\n  }\n}\n\nexport const run = (obj, keys = [], ...args) => {\n  keys = isString(keys) ? keys.split('.') : keys\n\n  const func = get(obj, keys)\n  const context = get(obj, keys.slice(0, -1))\n\n  return isFunction(func) ? func.call(context, ...args) : func\n}\n\nexport const value = (...values) =>\n  values.reduce(\n    (value, nextValue) => (isUndefined(value) ? run(nextValue) : run(value)),\n    undefined\n  )\n","const getImplementation = () => {\n  if (typeof self !== 'undefined') {\n    return self\n  }\n  if (typeof window !== 'undefined') {\n    return window\n  }\n  if (typeof global !== 'undefined') {\n    return global\n  }\n\n  throw new Error('unable to locate global object')\n}\n\nconst implementation = getImplementation()\n\nconst getGlobal = () => {\n  if (\n    typeof global !== 'object' ||\n    !global ||\n    global.Math !== Math ||\n    global.Array !== Array\n  ) {\n    return implementation\n  }\n  return global\n}\n\nconst globalThis = getGlobal()\n\nexport default globalThis\n","import { isArray } from './base/is'\n\nexport const nextTick = func => Promise.resolve().then(func)\n\nexport const flatten = array =>\n  array.reduce(\n    (res, item) => [...res, ...(isArray(item) ? flatten(item) : [item])],\n    []\n  )\n\n/**\n * [钳子] 用来将数字限制在给定范围内\n * @param {Number} value 被限制值\n * @param {Number} min 最小值\n * @param {Number} max 最大值\n */\nexport const clamp = (value, min, max = Number.MAX_VALUE) => {\n  if (value < min) {\n    return min\n  }\n\n  if (value > max) {\n    return max\n  }\n\n  return value\n}\n\nexport const ObjectValues = (object) => {\n  const res = []\n  for (let key in object) {\n    res.push(object[key])\n  }\n  return res\n}\n","import root from './base/globalThis'\nimport { get, run, value } from './base/try'\nimport { isArray, isFunction, isExist } from './base/is'\nimport { flatten } from './utils'\n\nconst body = get(root, 'document.body')\nconst screenScrollingElement = get(\n  root,\n  'document.scrollingElement',\n  get(root, 'document.documentElement', {})\n)\n\nfunction isScrollableNode(node = {}) {\n  if (!isExist(node)) {\n    return false\n  }\n\n  return (\n    node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight\n  )\n}\n\nfunction getScrollableNodes(from) {\n  if (!isFunction(get(root, 'document.getElementById'))) {\n    return []\n  }\n\n  return [...value(run(from, 'querySelectorAll', '*'), []), from].filter(\n    isScrollableNode\n  )\n}\n\nexport default function saveScrollPosition(from) {\n  const nodes = [\n    ...new Set([\n      ...flatten((!isArray(from) ? [from] : from).map(getScrollableNodes)),\n      ...[screenScrollingElement, body].filter(isScrollableNode)\n    ])\n  ]\n\n  const saver = nodes.map(node => [\n    node,\n    {\n      x: node.scrollLeft,\n      y: node.scrollTop\n    }\n  ])\n\n  return function revert() {\n    saver.forEach(([node, { x, y }]) => {\n      node.scrollLeft = x\n      node.scrollTop = y\n    })\n  }\n}\n","import CacheComponent from './CacheComponent'\nimport { get, run } from '../helpers'\n\nconst __components = {}\n\nconst getCachedComponentEntries = () =>\n  Object.entries(__components).filter(\n    ([, cache]) =>\n      cache instanceof CacheComponent\n        ? cache.state.cached\n        : Object.values(cache).some(cache => cache.state.cached)\n  )\n\nexport const getCache = () => ({ ...__components })\n\nexport const register = (key, component) => {\n  __components[key] = component\n}\n\nexport const remove = key => {\n  delete __components[key]\n}\n\nconst dropComponent = component => run(component, 'reset')\n\nexport const dropByCacheKey = key => {\n  const cache = get(__components, [key])\n\n  if (!cache) {\n    return\n  }\n\n  if (cache instanceof CacheComponent) {\n    dropComponent(cache)\n  } else {\n    Object.values(cache).forEach(dropComponent)\n  }\n}\n\nconst refreshComponent = component => run(component, 'refresh');\n\nexport const refreshByCacheKey = key => {\n  const cache = get(__components, [key]);\n\n  if (!cache) {\n    return;\n  }\n\n  if (cache instanceof CacheComponent) {\n    refreshComponent(cache);\n  } else {\n    Object.values(cache).forEach(refreshComponent);\n  }\n};\n\nexport const clearCache = () => {\n  getCachedComponentEntries().forEach(([key]) => dropByCacheKey(key))\n}\n\nexport const getCachingKeys = () =>\n  getCachedComponentEntries().map(([key]) => key)\n\nexport const getCachingComponents = () =>\n  getCachedComponentEntries().reduce(\n    (res, [key, cache]) => ({\n      ...res,\n      ...(cache instanceof CacheComponent\n        ? { [key]: cache }\n        : Object.entries(cache).reduce(\n            (res, [pathname, cache]) => ({\n              ...res,\n              [`${key}.${pathname}`]: cache\n            }),\n            {}\n          ))\n    }),\n    {}\n  )\n","import { useEffect, useContext } from 'react'\nimport createContext from 'mini-create-react-context'\n\nimport { isArray, isFunction, run } from '../helpers'\n\nconst context = createContext()\n\nexport default context\nexport const { Provider, Consumer } = context\n\nfunction useCacheRoute(lifecycleName, effect, deps = []) {\n  if (!isFunction(useContext)) {\n    return\n  }\n\n  const cacheLifecycles = useContext(context)\n  useEffect(() => {\n    const off = run(cacheLifecycles, 'on', lifecycleName, effect)\n\n    return () => run(off)\n  }, deps)\n}\nexport const useDidCache = useCacheRoute.bind(null, 'didCache')\nexport const useDidRecover = useCacheRoute.bind(null, 'didRecover')\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport {\r\n  run,\r\n  get,\r\n  value,\r\n  isExist,\r\n  isFunction,\r\n  saveScrollPosition,\r\n  ObjectValues\r\n} from '../helpers'\r\nimport * as manager from './manager'\r\nimport { Provider as CacheRouteProvider } from './context'\r\n\r\nconst isUsingNewLifecycle = isExist(React.forwardRef)\r\n\r\nexport const COMPUTED_UNMATCH_KEY = '__isComputedUnmatch'\r\nexport const isMatch = match =>\r\n  isExist(match) && get(match, COMPUTED_UNMATCH_KEY) !== true\r\n\r\nconst getDerivedStateFromProps = (nextProps, prevState) => {\r\n  let { match: nextPropsMatch, when = 'forward' } = nextProps\r\n\r\n  /**\r\n   * Note:\r\n   * Turn computedMatch from CacheSwitch to a real null value\r\n   *\r\n   * 将 CacheSwitch 计算得到的 computedMatch 值转换为真正的 null\r\n   */\r\n  if (!isMatch(nextPropsMatch)) {\r\n    nextPropsMatch = null\r\n  }\r\n\r\n  if (!prevState.cached && nextPropsMatch) {\r\n    return {\r\n      cached: true,\r\n      matched: true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determines whether it needs to cancel the cache based on the next unmatched props action\r\n   *\r\n   * 根据下个未匹配状态动作决定是否需要取消缓存\r\n   */\r\n  if (prevState.matched && !nextPropsMatch) {\r\n    const nextAction = get(nextProps, 'history.action')\r\n\r\n    let __cancel__cache = false\r\n\r\n    if (isFunction(when)) {\r\n      __cancel__cache = !when(nextProps)\r\n    } else {\r\n      switch (when) {\r\n        case 'always':\r\n          break\r\n        case 'back':\r\n          if (['PUSH', 'REPLACE'].includes(nextAction)) {\r\n            __cancel__cache = true\r\n          }\r\n\r\n          break\r\n        case 'forward':\r\n        default:\r\n          if (nextAction === 'POP') {\r\n            __cancel__cache = true\r\n          }\r\n      }\r\n    }\r\n\r\n    if (__cancel__cache) {\r\n      return {\r\n        cached: false,\r\n        matched: false\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    matched: !!nextPropsMatch\r\n  }\r\n}\r\n\r\nexport default class CacheComponent extends Component {\r\n  static __name = 'CacheComponent'\r\n\r\n  static propsTypes = {\r\n    history: PropTypes.object.isRequired,\r\n    match: PropTypes.object.isRequired,\r\n    children: PropTypes.func.isRequired,\r\n    className: PropTypes.string,\r\n    when: PropTypes.oneOfType([\r\n      PropTypes.func,\r\n      PropTypes.oneOf(['forward', 'back', 'always'])\r\n    ]),\r\n    behavior: PropTypes.func,\r\n    unmount: PropTypes.bool,\r\n    saveScrollPosition: PropTypes.bool\r\n  }\r\n\r\n  static defaultProps = {\r\n    when: 'forward',\r\n    unmount: false,\r\n    saveScrollPosition: false,\r\n    behavior: cached =>\r\n      cached\r\n        ? {\r\n            style: {\r\n              display: 'none'\r\n            }\r\n          }\r\n        : undefined\r\n  }\r\n\r\n  constructor(props, ...args) {\r\n    super(props, ...args)\r\n\r\n    this.__cacheCreateTime = Date.now()\r\n    this.__cacheUpdateTime = this.__cacheCreateTime\r\n    if (props.cacheKey) {\r\n      const cacheKey = run(props.cacheKey, undefined, props)\r\n      if (props.multiple) {\r\n        const { pathname } = props\r\n        manager.register(cacheKey, {\r\n          ...manager.getCache()[cacheKey],\r\n          [pathname]: this\r\n        })\r\n      } else {\r\n        manager.register(cacheKey, this)\r\n      }\r\n    }\r\n\r\n    if (typeof document !== 'undefined') {\r\n      const cacheKey = run(props.cacheKey, undefined, props)\r\n      this.__placeholderNode = document.createComment(\r\n        ` Route cached ${cacheKey ? `with cacheKey: \"${cacheKey}\" ` : ''}`\r\n      )\r\n    }\r\n\r\n    this.state = getDerivedStateFromProps(props, {\r\n      cached: false,\r\n      matched: false,\r\n      key: Math.random()\r\n    })\r\n  }\r\n\r\n  cacheLifecycles = {\r\n    __listener: {},\r\n    __didCacheListener: {},\r\n    __didRecoverListener: {},\r\n    on: (eventName, func) => {\r\n      const id = Math.random()\r\n      const listenerKey = `__${eventName}Listener`\r\n      this.cacheLifecycles[listenerKey][id] = func\r\n\r\n      return () => {\r\n        delete this.cacheLifecycles[listenerKey][id]\r\n      }\r\n    },\r\n    didCache: listener => {\r\n      this.cacheLifecycles.__listener['didCache'] = listener\r\n    },\r\n    didRecover: listener => {\r\n      this.cacheLifecycles.__listener['didRecover'] = listener\r\n    }\r\n  }\r\n\r\n  /**\r\n   * New lifecycle for replacing the `componentWillReceiveProps` in React 16.3 +\r\n   * React 16.3 + 版本中替代 componentWillReceiveProps 的新生命周期\r\n   */\r\n  static getDerivedStateFromProps = isUsingNewLifecycle\r\n    ? getDerivedStateFromProps\r\n    : undefined\r\n\r\n  /**\r\n   * Compatible React 16.3 -\r\n   * 兼容 React 16.3 - 版本\r\n   */\r\n  componentWillReceiveProps = !isUsingNewLifecycle\r\n    ? nextProps => {\r\n        const nextState = getDerivedStateFromProps(nextProps, this.state)\r\n\r\n        this.setState(nextState)\r\n      }\r\n    : undefined\r\n\r\n  __parentNode\r\n  __placeholderNode\r\n  __revertScrollPos\r\n  injectDOM = () => {\r\n    try {\r\n      run(\r\n        this.__parentNode,\r\n        'insertBefore',\r\n        this.wrapper,\r\n        this.__placeholderNode\r\n      )\r\n      run(this.__parentNode, 'removeChild', this.__placeholderNode)\r\n    } catch (err) {\r\n      // nothing\r\n    }\r\n  }\r\n\r\n  ejectDOM = () => {\r\n    try {\r\n      const parentNode = get(this.wrapper, 'parentNode')\r\n      this.__parentNode = parentNode\r\n\r\n      run(\r\n        this.__parentNode,\r\n        'insertBefore',\r\n        this.__placeholderNode,\r\n        this.wrapper\r\n      )\r\n      run(this.__parentNode, 'removeChild', this.wrapper)\r\n    } catch (err) {\r\n      // nothing\r\n    }\r\n  }\r\n  componentDidUpdate(prevProps, prevState) {\r\n    if (!prevState.cached || !this.state.cached) {\r\n      return\r\n    }\r\n\r\n    if (prevState.matched === true && this.state.matched === false) {\r\n      if (this.props.unmount) {\r\n        this.ejectDOM()\r\n      }\r\n      this.__cacheUpdateTime = Date.now()\r\n      ObjectValues(this.cacheLifecycles.__didCacheListener).forEach(func => {\r\n        run(func)\r\n      })\r\n      return run(this, 'cacheLifecycles.__listener.didCache')\r\n    }\r\n\r\n    if (prevState.matched === false && this.state.matched === true) {\r\n      if (this.props.saveScrollPosition) {\r\n        run(this.__revertScrollPos)\r\n      }\r\n      this.__cacheUpdateTime = Date.now()\r\n      ObjectValues(this.cacheLifecycles.__didRecoverListener).forEach(func => {\r\n        run(func)\r\n      })\r\n      return run(this, 'cacheLifecycles.__listener.didRecover')\r\n    }\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    const willRecover =\r\n      this.state.matched === false && nextState.matched === true\r\n    const willDrop = this.state.cached === true && nextState.cached === false\r\n    const shouldUpdate =\r\n      this.state.matched ||\r\n      nextState.matched ||\r\n      this.state.cached !== nextState.cached\r\n\r\n    if (shouldUpdate) {\r\n      if ((this.props.unmount && willDrop) || willRecover) {\r\n        this.injectDOM()\r\n      }\r\n\r\n      if (!(willDrop || willRecover) && this.props.saveScrollPosition) {\r\n        this.__revertScrollPos = saveScrollPosition(\r\n          this.props.unmount ? this.wrapper : undefined\r\n        )\r\n      }\r\n    }\r\n\r\n    return shouldUpdate\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    const { unmount, pathname, multiple } = this.props\r\n    const cacheKey = run(this.props, 'cacheKey', this.props)\r\n\r\n    if (multiple) {\r\n      const cache = { ...manager.getCache()[cacheKey] }\r\n\r\n      delete cache[pathname]\r\n\r\n      if (Object.keys(cache).length === 0) {\r\n        manager.remove(cacheKey)\r\n      } else {\r\n        manager.register(cacheKey, cache)\r\n      }\r\n    } else {\r\n      manager.remove(cacheKey)\r\n    }\r\n\r\n    if (unmount) {\r\n      this.injectDOM()\r\n    }\r\n  }\r\n\r\n  reset = () => {\r\n    delete this.__revertScrollPos\r\n\r\n    this.setState({\r\n      cached: false\r\n    })\r\n  }\r\n\r\n  refresh = () => {\r\n    delete this.__revertScrollPos;\r\n\r\n    this.setState({\r\n      key: Math.random()\r\n    });\r\n  };\r\n\r\n  render() {\r\n    const { matched, cached, key } = this.state\r\n    const { className: propsClassName = '', behavior, children } = this.props\r\n    const { className: behaviorClassName = '', ...behaviorProps } = value(\r\n      run(behavior, undefined, !matched),\r\n      {}\r\n    )\r\n    const className = run(`${propsClassName} ${behaviorClassName}`, 'trim')\r\n    const hasClassName = className !== ''\r\n\r\n    return cached ? (\r\n      <div\r\n        key={key}\r\n        className={hasClassName ? className : undefined}\r\n        {...behaviorProps}\r\n        ref={wrapper => {\r\n          this.wrapper = wrapper\r\n        }}\r\n      >\r\n        <CacheRouteProvider value={this.cacheLifecycles}>\r\n          {run(children, undefined, this.cacheLifecycles)}\r\n        </CacheRouteProvider>\r\n      </div>\r\n    ) : null\r\n  }\r\n}\r\n","import { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { run, get } from '../helpers'\n\nexport default class Updatable extends Component {\n  static propsTypes = {\n    when: PropTypes.bool.isRequired\n  }\n\n  render = () => run(this.props, 'children')\n  shouldComponentUpdate = ({ when }) => when\n}\n","import React, { Component, Fragment } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Route } from 'react-router-dom'\r\n\r\nimport CacheComponent, { isMatch } from '../core/CacheComponent'\r\nimport Updatable from '../core/Updatable'\r\nimport { run, isExist, isNumber, clamp } from '../helpers'\r\n\r\nconst isEmptyChildren = children => React.Children.count(children) === 0\r\nconst isFragmentable = isExist(Fragment)\r\n\r\nexport default class CacheRoute extends Component {\r\n  static __name = 'CacheRoute'\r\n\r\n  static propTypes = {\r\n    component: PropTypes.elementType || PropTypes.any,\r\n    render: PropTypes.func,\r\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\r\n    computedMatchForCacheRoute: PropTypes.object,\r\n    multiple: PropTypes.oneOfType([PropTypes.bool, PropTypes.number])\r\n  }\r\n\r\n  static defaultProps = {\r\n    multiple: false\r\n  }\r\n\r\n  cache = {}\r\n\r\n  render() {\r\n    let {\r\n      children,\r\n      render,\r\n      component,\r\n      className,\r\n      when,\r\n      behavior,\r\n      cacheKey,\r\n      unmount,\r\n      saveScrollPosition,\r\n      computedMatchForCacheRoute,\r\n      multiple,\r\n      ...restProps\r\n    } = this.props\r\n\r\n    /**\r\n     * Note:\r\n     * If children prop is a React Element, define the corresponding wrapper component for supporting multiple children\r\n     *\r\n     * 说明：如果 children 属性是 React Element 则定义对应的包裹组件以支持多个子组件\r\n     */\r\n    if (React.isValidElement(children) || !isEmptyChildren(children)) {\r\n      render = () => children\r\n    }\r\n\r\n    if (computedMatchForCacheRoute) {\r\n      restProps.computedMatch = computedMatchForCacheRoute\r\n    }\r\n\r\n    if (multiple && !isFragmentable) {\r\n      multiple = false\r\n    }\r\n\r\n    if (isNumber(multiple)) {\r\n      multiple = clamp(multiple, 1)\r\n    }\r\n\r\n    return (\r\n      /**\r\n       * Only children prop of Route can help to control rendering behavior\r\n       * 只有 Router 的 children 属性有助于主动控制渲染行为\r\n       */\r\n      <Route {...restProps}>\r\n        {props => {\r\n          const { match, computedMatch, location } = props\r\n          const isMatchCurrentRoute = isMatch(props.match)\r\n          const { pathname: currentPathname, search: currentSearch } = location\r\n          const maxMultipleCount = isNumber(multiple) ? multiple : Infinity\r\n          const configProps = {\r\n            when,\r\n            className,\r\n            behavior,\r\n            cacheKey,\r\n            unmount,\r\n            saveScrollPosition\r\n          }\r\n\r\n          const renderSingle = props => (\r\n            <CacheComponent {...props}>\r\n              {cacheLifecycles => (\r\n                <Updatable when={isMatch(props.match)}>\r\n                  {() => {\r\n                    Object.assign(props, { cacheLifecycles })\r\n\r\n                    if (component) {\r\n                      return React.createElement(component, props)\r\n                    }\r\n\r\n                    return run(render || children, undefined, props)\r\n                  }}\r\n                </Updatable>\r\n              )}\r\n            </CacheComponent>\r\n          )\r\n\r\n          if (multiple && isMatchCurrentRoute) {\r\n            this.cache[currentPathname + currentSearch] = {\r\n              updateTime: Date.now(),\r\n              pathname: currentPathname,\r\n              search: currentSearch,\r\n              render: renderSingle\r\n            }\r\n\r\n            Object.entries(this.cache)\r\n              .sort(([, prev], [, next]) => next.updateTime - prev.updateTime)\r\n              .forEach(([pathname], idx) => {\r\n                if (idx >= maxMultipleCount) {\r\n                  delete this.cache[pathname]\r\n                }\r\n              })\r\n          }\r\n\r\n          return multiple ? (\r\n            <Fragment>\r\n              {Object.entries(this.cache).map(([multipleCacheKey, { render, pathname }]) => {\r\n                const recomputedMatch =\r\n                  multipleCacheKey === currentPathname + currentSearch ? match || computedMatch : null\r\n\r\n                return (\r\n                  <Fragment key={multipleCacheKey}>\r\n                    {render({\r\n                      ...props,\r\n                      ...configProps,\r\n                      pathname,\r\n                      cacheKey,\r\n                      multiple: true,\r\n                      key: pathname,\r\n                      match: recomputedMatch\r\n                    })}\r\n                  </Fragment>\r\n                )\r\n              })}\r\n            </Fragment>\r\n          ) : (\r\n            renderSingle({\r\n              ...props,\r\n              ...configProps,\r\n              pathname: currentPathname,\r\n              multiple: false\r\n            })\r\n          )\r\n        }}\r\n      </Route>\r\n    )\r\n  }\r\n}\r\n","import React, { PropTypes, Fragment } from 'react'\n\nimport { isExist } from '../helpers'\n\nfunction getFragment() {\n  if (isExist(Fragment)) {\n    return ({ children }) => <Fragment>{children}</Fragment>\n  }\n\n  if (isExist(PropTypes)) {\n    return ({ children }) => <div>{children}</div>\n  }\n\n  return ({ children }) => children\n}\n\nconst SwitchFragment = getFragment()\nSwitchFragment.displayName = 'SwitchFragment'\n\nexport default SwitchFragment\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Switch,\n  matchPath,\n  withRouter,\n  useHistory,\n  __RouterContext\n} from 'react-router-dom'\n\nimport { COMPUTED_UNMATCH_KEY, isMatch } from '../core/CacheComponent'\nimport Updatable from '../core/Updatable'\nimport SwitchFragment from './SwitchFragment'\nimport { get, isNull, isExist } from '../helpers'\n\nconst isUsingNewContext = isExist(__RouterContext) || isExist(useHistory)\n\nclass CacheSwitch extends Switch {\n  getContext = () => {\n    if (isUsingNewContext) {\n      const { location, match } = this.props\n\n      return { location, match }\n    } else {\n      const { route } = this.context.router\n      const location = this.props.location || route.location\n\n      return {\n        location,\n        match: route.match\n      }\n    }\n  }\n\n  render() {\n    const { children, which } = this.props\n    const { location, match: contextMatch } = this.getContext()\n\n    let __matchedAlready = false\n\n    return (\n      <Updatable when={isMatch(contextMatch)}>\n        {() => (\n          <SwitchFragment>\n            {React.Children.map(children, element => {\n              if (!React.isValidElement(element)) {\n                return null\n              }\n\n              const path = element.props.path || element.props.from\n              const match = __matchedAlready\n                ? null\n                : path\n                  ? matchPath(\n                      location.pathname,\n                      {\n                        ...element.props,\n                        path\n                      },\n                      contextMatch\n                    )\n                  : contextMatch\n\n              let child\n\n              if (which(element)) {\n                child = React.cloneElement(element, {\n                  location,\n                  computedMatch: match,\n                  /**\n                   * https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js#L57\n                   *\n                   * Note:\n                   * Route would use computedMatch as its next match state ONLY when computedMatch is a true value\n                   * So here we have to do some trick to let the unmatch result pass Route's computedMatch check\n                   *\n                   * 注意：只有当 computedMatch 为真值时，Route 才会使用 computedMatch 作为其下一个匹配状态\n                   * 所以这里我们必须做一些手脚，让 unmatch 结果通过 Route 的 computedMatch 检查\n                   */\n                  ...(isNull(match)\n                    ? {\n                        computedMatchForCacheRoute: {\n                          [COMPUTED_UNMATCH_KEY]: true\n                        }\n                      }\n                    : null)\n                })\n              } else {\n                child =\n                  match && !__matchedAlready\n                    ? React.cloneElement(element, {\n                        location,\n                        computedMatch: match\n                      })\n                    : null\n              }\n\n              if (!__matchedAlready) {\n                __matchedAlready = !!match\n              }\n\n              return child\n            })}\n          </SwitchFragment>\n        )}\n      </Updatable>\n    )\n  }\n}\n\nif (isUsingNewContext) {\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object.isRequired,\n    match: PropTypes.object.isRequired,\n    which: PropTypes.func\n  }\n\n  CacheSwitch = withRouter(CacheSwitch)\n} else {\n  CacheSwitch.contextTypes = {\n    router: PropTypes.shape({\n      route: PropTypes.object.isRequired\n    }).isRequired\n  }\n\n  CacheSwitch.propTypes = {\n    children: PropTypes.node,\n    location: PropTypes.object,\n    which: PropTypes.func\n  }\n}\n\nCacheSwitch.defaultProps = {\n  which: element => get(element, 'type.__name') === 'CacheRoute'\n}\n\nexport default CacheSwitch\n"]},"metadata":{},"sourceType":"script"}