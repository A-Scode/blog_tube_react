{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.TypeParameterDeclaration = exports.StringLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = exports.GenericTypeAnnotation = exports.ClassImplements = undefined;\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.ExistentialTypeParam = ExistentialTypeParam;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.InterfaceExtends = InterfaceExtends;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\n\nvar _types = require(\"./types\");\n\nObject.defineProperty(exports, \"NumericLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.NumericLiteral;\n  }\n});\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.StringLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.OpaqueType = OpaqueType;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    var declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistentialTypeParam() {\n  this.token(\"*\");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  if (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\") {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nexports.ClassImplements = InterfaceExtends;\nexports.GenericTypeAnnotation = InterfaceExtends;\n\nfunction _interfaceish(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance === \"plus\") {\n    this.token(\"+\");\n  } else if (node.variance === \"minus\") {\n    this.token(\"-\");\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nexports.TypeParameterDeclaration = TypeParameterInstantiation;\n\nfunction ObjectTypeAnnotation(node) {\n  var _this = this;\n\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  var props = node.properties.concat(node.callProperties, node.indexers);\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines: function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: function iterator() {\n        if (props.length !== 1) {\n          if (_this.format.flowCommaSeparator) {\n            _this.token(\",\");\n          } else {\n            _this.semicolon();\n          }\n\n          _this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\":\");\n  this.space();\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/babel-generator/lib/generators/flow.js"],"names":["exports","__esModule","TypeParameterDeclaration","StringLiteralTypeAnnotation","NumericLiteralTypeAnnotation","GenericTypeAnnotation","ClassImplements","undefined","AnyTypeAnnotation","ArrayTypeAnnotation","BooleanTypeAnnotation","BooleanLiteralTypeAnnotation","NullLiteralTypeAnnotation","DeclareClass","DeclareFunction","DeclareInterface","DeclareModule","DeclareModuleExports","DeclareTypeAlias","DeclareOpaqueType","DeclareVariable","DeclareExportDeclaration","ExistentialTypeParam","FunctionTypeAnnotation","FunctionTypeParam","InterfaceExtends","_interfaceish","_variance","InterfaceDeclaration","IntersectionTypeAnnotation","MixedTypeAnnotation","EmptyTypeAnnotation","NullableTypeAnnotation","_types","require","Object","defineProperty","enumerable","get","NumericLiteral","StringLiteral","NumberTypeAnnotation","StringTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeofTypeAnnotation","TypeAlias","OpaqueType","TypeAnnotation","TypeParameter","TypeParameterInstantiation","ObjectTypeAnnotation","ObjectTypeCallProperty","ObjectTypeIndexer","ObjectTypeProperty","ObjectTypeSpreadProperty","QualifiedTypeIdentifier","UnionTypeAnnotation","TypeCastExpression","VoidTypeAnnotation","_babelTypes","t","_interopRequireWildcard","obj","newObj","key","prototype","hasOwnProperty","call","default","word","node","print","elementType","token","value","parent","isDeclareExportDeclaration","space","id","typeAnnotation","semicolon","body","FlowExportDeclaration","apply","arguments","declaration","declar","isStatement","specifiers","length","printList","source","typeParameters","params","rest","type","returnType","name","optional","extends","mixins","variance","andSeparator","printJoin","types","separator","argument","right","supertype","impltype","bound","_this","exact","props","properties","concat","callProperties","indexers","addNewlines","leading","indent","statement","iterator","format","flowCommaSeparator","static","qualification","orSeparator","expression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.TypeParameterDeclaration = exports.StringLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = exports.GenericTypeAnnotation = exports.ClassImplements = undefined;\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.ExistentialTypeParam = ExistentialTypeParam;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.InterfaceExtends = InterfaceExtends;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\n\nvar _types = require(\"./types\");\n\nObject.defineProperty(exports, \"NumericLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.NumericLiteral;\n  }\n});\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.StringLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.OpaqueType = OpaqueType;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    var declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistentialTypeParam() {\n  this.token(\"*\");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  if (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\") {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nexports.ClassImplements = InterfaceExtends;\nexports.GenericTypeAnnotation = InterfaceExtends;\nfunction _interfaceish(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance === \"plus\") {\n    this.token(\"+\");\n  } else if (node.variance === \"minus\") {\n    this.token(\"-\");\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, { separator: andSeparator });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nexports.TypeParameterDeclaration = TypeParameterInstantiation;\nfunction ObjectTypeAnnotation(node) {\n  var _this = this;\n\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  var props = node.properties.concat(node.callProperties, node.indexers);\n\n  if (props.length) {\n    this.space();\n\n    this.printJoin(props, node, {\n      addNewlines: function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n\n      indent: true,\n      statement: true,\n      iterator: function iterator() {\n        if (props.length !== 1) {\n          if (_this.format.flowCommaSeparator) {\n            _this.token(\",\");\n          } else {\n            _this.semicolon();\n          }\n          _this.space();\n        }\n      }\n    });\n\n    this.space();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\":\");\n  this.space();\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, { separator: orSeparator });\n}\n\nfunction TypeCastExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}"]},"metadata":{},"sourceType":"script"}