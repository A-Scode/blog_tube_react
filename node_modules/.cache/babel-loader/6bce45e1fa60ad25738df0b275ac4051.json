{"ast":null,"code":"/* eslint-disable guard-for-in */\n'use strict';\n\nvar repeating = require('repeating'); // detect either spaces or tabs but not both to properly handle tabs\n// for indentation and spaces for alignment\n\n\nvar INDENT_RE = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n  var result = 0;\n  var maxUsed = 0;\n  var maxWeight = 0;\n\n  for (var n in indents) {\n    var indent = indents[n];\n    var u = indent[0];\n    var w = indent[1];\n\n    if (u > maxUsed || u === maxUsed && w > maxWeight) {\n      maxUsed = u;\n      maxWeight = w;\n      result = Number(n);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  } // used to see if tabs or spaces are the most used\n\n\n  var tabs = 0;\n  var spaces = 0; // remember the size of previous line's indentation\n\n  var prev = 0; // remember how many indents/unindents as occurred for a given size\n  // and how much lines follow a given indentation\n  //\n  // indents = {\n  //    3: [1, 0],\n  //    4: [1, 5],\n  //    5: [1, 0],\n  //   12: [1, 0],\n  // }\n\n  var indents = {}; // pointer to the array of last used indent\n\n  var current; // whether the last action was an indent (opposed to an unindent)\n\n  var isIndent;\n  str.split(/\\n/g).forEach(function (line) {\n    if (!line) {\n      // ignore empty lines\n      return;\n    }\n\n    var indent;\n    var matches = line.match(INDENT_RE);\n\n    if (!matches) {\n      indent = 0;\n    } else {\n      indent = matches[0].length;\n\n      if (matches[1]) {\n        spaces++;\n      } else {\n        tabs++;\n      }\n    }\n\n    var diff = indent - prev;\n    prev = indent;\n\n    if (diff) {\n      // an indent or unindent has been detected\n      isIndent = diff > 0;\n      current = indents[isIndent ? diff : -diff];\n\n      if (current) {\n        current[0]++;\n      } else {\n        current = indents[diff] = [1, 0];\n      }\n    } else if (current) {\n      // if the last action was an indent, increment the weight\n      current[1] += Number(isIndent);\n    }\n  });\n  var amount = getMostUsed(indents);\n  var type;\n  var actual;\n\n  if (!amount) {\n    type = null;\n    actual = '';\n  } else if (spaces >= tabs) {\n    type = 'space';\n    actual = repeating(' ', amount);\n  } else {\n    type = 'tab';\n    actual = repeating('\\t', amount);\n  }\n\n  return {\n    amount: amount,\n    type: type,\n    indent: actual\n  };\n};","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/detect-indent/index.js"],"names":["repeating","require","INDENT_RE","getMostUsed","indents","result","maxUsed","maxWeight","n","indent","u","w","Number","module","exports","str","TypeError","tabs","spaces","prev","current","isIndent","split","forEach","line","matches","match","length","diff","amount","type","actual"],"mappings":"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","sourcesContent":["/* eslint-disable guard-for-in */\n'use strict';\nvar repeating = require('repeating');\n\n// detect either spaces or tabs but not both to properly handle tabs\n// for indentation and spaces for alignment\nvar INDENT_RE = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n\tvar result = 0;\n\tvar maxUsed = 0;\n\tvar maxWeight = 0;\n\n\tfor (var n in indents) {\n\t\tvar indent = indents[n];\n\t\tvar u = indent[0];\n\t\tvar w = indent[1];\n\n\t\tif (u > maxUsed || u === maxUsed && w > maxWeight) {\n\t\t\tmaxUsed = u;\n\t\t\tmaxWeight = w;\n\t\t\tresult = Number(n);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// used to see if tabs or spaces are the most used\n\tvar tabs = 0;\n\tvar spaces = 0;\n\n\t// remember the size of previous line's indentation\n\tvar prev = 0;\n\n\t// remember how many indents/unindents as occurred for a given size\n\t// and how much lines follow a given indentation\n\t//\n\t// indents = {\n\t//    3: [1, 0],\n\t//    4: [1, 5],\n\t//    5: [1, 0],\n\t//   12: [1, 0],\n\t// }\n\tvar indents = {};\n\n\t// pointer to the array of last used indent\n\tvar current;\n\n\t// whether the last action was an indent (opposed to an unindent)\n\tvar isIndent;\n\n\tstr.split(/\\n/g).forEach(function (line) {\n\t\tif (!line) {\n\t\t\t// ignore empty lines\n\t\t\treturn;\n\t\t}\n\n\t\tvar indent;\n\t\tvar matches = line.match(INDENT_RE);\n\n\t\tif (!matches) {\n\t\t\tindent = 0;\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\n\t\t\tif (matches[1]) {\n\t\t\t\tspaces++;\n\t\t\t} else {\n\t\t\t\ttabs++;\n\t\t\t}\n\t\t}\n\n\t\tvar diff = indent - prev;\n\t\tprev = indent;\n\n\t\tif (diff) {\n\t\t\t// an indent or unindent has been detected\n\n\t\t\tisIndent = diff > 0;\n\n\t\t\tcurrent = indents[isIndent ? diff : -diff];\n\n\t\t\tif (current) {\n\t\t\t\tcurrent[0]++;\n\t\t\t} else {\n\t\t\t\tcurrent = indents[diff] = [1, 0];\n\t\t\t}\n\t\t} else if (current) {\n\t\t\t// if the last action was an indent, increment the weight\n\t\t\tcurrent[1] += Number(isIndent);\n\t\t}\n\t});\n\n\tvar amount = getMostUsed(indents);\n\n\tvar type;\n\tvar actual;\n\tif (!amount) {\n\t\ttype = null;\n\t\tactual = '';\n\t} else if (spaces >= tabs) {\n\t\ttype = 'space';\n\t\tactual = repeating(' ', amount);\n\t} else {\n\t\ttype = 'tab';\n\t\tactual = repeating('\\t', amount);\n\t}\n\n\treturn {\n\t\tamount: amount,\n\t\ttype: type,\n\t\tindent: actual\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}