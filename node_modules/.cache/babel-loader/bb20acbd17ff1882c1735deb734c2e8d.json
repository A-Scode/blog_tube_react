{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n  var binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  var testType = getConditionalAnnotation(path, name);\n\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n\n    var status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n  var target = void 0;\n\n  if (left.isIdentifier({\n    name: name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name: name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typePath && !typeofPath) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name: name\n  })) return;\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\n\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/babel-traverse/lib/path/inference/inferer-reference.js"],"names":["exports","__esModule","_getIterator2","require","_getIterator3","_interopRequireDefault","default","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","t","voidTypeAnnotation","numberTypeAnnotation","_babelTypes","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","path","types","unionTypeAnnotation","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","concat","_iterator","_isArray","Array","isArray","_i","_ref","next","done","value","violation","getTypeAnnotation","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","test","paths","_path","shift","isLogicalExpression","isBinaryExpression","type","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = void 0;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}