{"ast":null,"code":"// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\nvar JSON5 = typeof exports === 'object' ? exports : {};\n\nJSON5.parse = function () {\n  \"use strict\"; // This is a function that can parse a JSON5 text, producing a JavaScript\n  // data structure. It is a simple, recursive descent parser. It does not use\n  // eval or regular expressions, so it can be used as a model for implementing\n  // a JSON5 parser in other languages.\n  // We are defining the function inside of another function to avoid creating\n  // global variables.\n\n  var at,\n      // The index of the current character\n  lineNumber,\n      // The current line number\n  columnNumber,\n      // The current column number\n  ch,\n      // The current character\n  escapee = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    '\\n': '',\n    // Replace escaped newlines in strings w/ empty string\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n  },\n      ws = [' ', '\\t', '\\r', '\\n', '\\v', '\\f', '\\xA0', '\\uFEFF'],\n      text,\n      renderChar = function (chr) {\n    return chr === '' ? 'EOF' : \"'\" + chr + \"'\";\n  },\n      error = function (m) {\n    // Call error when something is wrong.\n    var error = new SyntaxError(); // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n\n    error.message = m + \" at line \" + lineNumber + \" column \" + columnNumber + \" of the JSON5 data. Still to read: \" + JSON.stringify(text.substring(at - 1, at + 19));\n    error.at = at; // These two property names have been chosen to agree with the ones in Gecko, the only popular\n    // environment which seems to supply this info on JSON.parse\n\n    error.lineNumber = lineNumber;\n    error.columnNumber = columnNumber;\n    throw error;\n  },\n      next = function (c) {\n    // If a c parameter is provided, verify that it matches the current character.\n    if (c && c !== ch) {\n      error(\"Expected \" + renderChar(c) + \" instead of \" + renderChar(ch));\n    } // Get the next character. When there are no more characters,\n    // return the empty string.\n\n\n    ch = text.charAt(at);\n    at++;\n    columnNumber++;\n\n    if (ch === '\\n' || ch === '\\r' && peek() !== '\\n') {\n      lineNumber++;\n      columnNumber = 0;\n    }\n\n    return ch;\n  },\n      peek = function () {\n    // Get the next character without consuming it or\n    // assigning it to the ch varaible.\n    return text.charAt(at);\n  },\n      identifier = function () {\n    // Parse an identifier. Normally, reserved words are disallowed here, but we\n    // only use this for unquoted object keys, where reserved words are allowed,\n    // so we don't check for those here. References:\n    // - http://es5.github.com/#x7.6\n    // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n    // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n    // TODO Identifiers can have Unicode \"letters\" in them; add support for those.\n    var key = ch; // Identifiers must start with a letter, _ or $.\n\n    if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {\n      error(\"Bad identifier as unquoted key\");\n    } // Subsequent characters can contain digits.\n\n\n    while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {\n      key += ch;\n    }\n\n    return key;\n  },\n      number = function () {\n    // Parse a number value.\n    var number,\n        sign = '',\n        string = '',\n        base = 10;\n\n    if (ch === '-' || ch === '+') {\n      sign = ch;\n      next(ch);\n    } // support for Infinity (could tweak to allow other words):\n\n\n    if (ch === 'I') {\n      number = word();\n\n      if (typeof number !== 'number' || isNaN(number)) {\n        error('Unexpected word for number');\n      }\n\n      return sign === '-' ? -number : number;\n    } // support for NaN\n\n\n    if (ch === 'N') {\n      number = word();\n\n      if (!isNaN(number)) {\n        error('expected word to be NaN');\n      } // ignore sign as -NaN also is NaN\n\n\n      return number;\n    }\n\n    if (ch === '0') {\n      string += ch;\n      next();\n\n      if (ch === 'x' || ch === 'X') {\n        string += ch;\n        next();\n        base = 16;\n      } else if (ch >= '0' && ch <= '9') {\n        error('Octal literal');\n      }\n    }\n\n    switch (base) {\n      case 10:\n        while (ch >= '0' && ch <= '9') {\n          string += ch;\n          next();\n        }\n\n        if (ch === '.') {\n          string += '.';\n\n          while (next() && ch >= '0' && ch <= '9') {\n            string += ch;\n          }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n          string += ch;\n          next();\n\n          if (ch === '-' || ch === '+') {\n            string += ch;\n            next();\n          }\n\n          while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n          }\n        }\n\n        break;\n\n      case 16:\n        while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n          string += ch;\n          next();\n        }\n\n        break;\n    }\n\n    if (sign === '-') {\n      number = -string;\n    } else {\n      number = +string;\n    }\n\n    if (!isFinite(number)) {\n      error(\"Bad number\");\n    } else {\n      return number;\n    }\n  },\n      string = function () {\n    // Parse a string value.\n    var hex,\n        i,\n        string = '',\n        delim,\n        // double quote or single quote\n    uffff; // When parsing for string values, we must look for ' or \" and \\ characters.\n\n    if (ch === '\"' || ch === \"'\") {\n      delim = ch;\n\n      while (next()) {\n        if (ch === delim) {\n          next();\n          return string;\n        } else if (ch === '\\\\') {\n          next();\n\n          if (ch === 'u') {\n            uffff = 0;\n\n            for (i = 0; i < 4; i += 1) {\n              hex = parseInt(next(), 16);\n\n              if (!isFinite(hex)) {\n                break;\n              }\n\n              uffff = uffff * 16 + hex;\n            }\n\n            string += String.fromCharCode(uffff);\n          } else if (ch === '\\r') {\n            if (peek() === '\\n') {\n              next();\n            }\n          } else if (typeof escapee[ch] === 'string') {\n            string += escapee[ch];\n          } else {\n            break;\n          }\n        } else if (ch === '\\n') {\n          // unescaped newlines are invalid; see:\n          // https://github.com/aseemk/json5/issues/24\n          // TODO this feels special-cased; are there other\n          // invalid unescaped chars?\n          break;\n        } else {\n          string += ch;\n        }\n      }\n    }\n\n    error(\"Bad string\");\n  },\n      inlineComment = function () {\n    // Skip an inline comment, assuming this is one. The current character should\n    // be the second / character in the // pair that begins this inline comment.\n    // To finish the inline comment, we look for a newline or the end of the text.\n    if (ch !== '/') {\n      error(\"Not an inline comment\");\n    }\n\n    do {\n      next();\n\n      if (ch === '\\n' || ch === '\\r') {\n        next();\n        return;\n      }\n    } while (ch);\n  },\n      blockComment = function () {\n    // Skip a block comment, assuming this is one. The current character should be\n    // the * character in the /* pair that begins this block comment.\n    // To finish the block comment, we look for an ending */ pair of characters,\n    // but we also watch for the end of text before the comment is terminated.\n    if (ch !== '*') {\n      error(\"Not a block comment\");\n    }\n\n    do {\n      next();\n\n      while (ch === '*') {\n        next('*');\n\n        if (ch === '/') {\n          next('/');\n          return;\n        }\n      }\n    } while (ch);\n\n    error(\"Unterminated block comment\");\n  },\n      comment = function () {\n    // Skip a comment, whether inline or block-level, assuming this is one.\n    // Comments always begin with a / character.\n    if (ch !== '/') {\n      error(\"Not a comment\");\n    }\n\n    next('/');\n\n    if (ch === '/') {\n      inlineComment();\n    } else if (ch === '*') {\n      blockComment();\n    } else {\n      error(\"Unrecognized comment\");\n    }\n  },\n      white = function () {\n    // Skip whitespace and comments.\n    // Note that we're detecting comments by only a single / character.\n    // This works since regular expressions are not valid JSON(5), but this will\n    // break if there are other valid values that begin with a / character!\n    while (ch) {\n      if (ch === '/') {\n        comment();\n      } else if (ws.indexOf(ch) >= 0) {\n        next();\n      } else {\n        return;\n      }\n    }\n  },\n      word = function () {\n    // true, false, or null.\n    switch (ch) {\n      case 't':\n        next('t');\n        next('r');\n        next('u');\n        next('e');\n        return true;\n\n      case 'f':\n        next('f');\n        next('a');\n        next('l');\n        next('s');\n        next('e');\n        return false;\n\n      case 'n':\n        next('n');\n        next('u');\n        next('l');\n        next('l');\n        return null;\n\n      case 'I':\n        next('I');\n        next('n');\n        next('f');\n        next('i');\n        next('n');\n        next('i');\n        next('t');\n        next('y');\n        return Infinity;\n\n      case 'N':\n        next('N');\n        next('a');\n        next('N');\n        return NaN;\n    }\n\n    error(\"Unexpected \" + renderChar(ch));\n  },\n      value,\n      // Place holder for the value function.\n  array = function () {\n    // Parse an array value.\n    var array = [];\n\n    if (ch === '[') {\n      next('[');\n      white();\n\n      while (ch) {\n        if (ch === ']') {\n          next(']');\n          return array; // Potentially empty array\n        } // ES5 allows omitting elements in arrays, e.g. [,] and\n        // [,null]. We don't allow this in JSON5.\n\n\n        if (ch === ',') {\n          error(\"Missing array element\");\n        } else {\n          array.push(value());\n        }\n\n        white(); // If there's no comma after this value, this needs to\n        // be the end of the array.\n\n        if (ch !== ',') {\n          next(']');\n          return array;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad array\");\n  },\n      object = function () {\n    // Parse an object value.\n    var key,\n        object = {};\n\n    if (ch === '{') {\n      next('{');\n      white();\n\n      while (ch) {\n        if (ch === '}') {\n          next('}');\n          return object; // Potentially empty object\n        } // Keys can be unquoted. If they are, they need to be\n        // valid JS identifiers.\n\n\n        if (ch === '\"' || ch === \"'\") {\n          key = string();\n        } else {\n          key = identifier();\n        }\n\n        white();\n        next(':');\n        object[key] = value();\n        white(); // If there's no comma after this pair, this needs to be\n        // the end of the object.\n\n        if (ch !== ',') {\n          next('}');\n          return object;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad object\");\n  };\n\n  value = function () {\n    // Parse a JSON value. It could be an object, an array, a string, a number,\n    // or a word.\n    white();\n\n    switch (ch) {\n      case '{':\n        return object();\n\n      case '[':\n        return array();\n\n      case '\"':\n      case \"'\":\n        return string();\n\n      case '-':\n      case '+':\n      case '.':\n        return number();\n\n      default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n  }; // Return the json_parse function. It will have access to all of the above\n  // functions and variables.\n\n\n  return function (source, reviver) {\n    var result;\n    text = String(source);\n    at = 0;\n    lineNumber = 1;\n    columnNumber = 1;\n    ch = ' ';\n    result = value();\n    white();\n\n    if (ch) {\n      error(\"Syntax error\");\n    } // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n\n    return typeof reviver === 'function' ? function walk(holder, key) {\n      var k,\n          v,\n          value = holder[key];\n\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n\n      return reviver.call(holder, key, value);\n    }({\n      '': result\n    }, '') : result;\n  };\n}(); // JSON5 stringify will not quote keys where appropriate\n\n\nJSON5.stringify = function (obj, replacer, space) {\n  if (replacer && typeof replacer !== \"function\" && !isArray(replacer)) {\n    throw new Error('Replacer must be a function or an array');\n  }\n\n  var getReplacedValueOrUndefined = function (holder, key, isTopLevel) {\n    var value = holder[key]; // Replace the value with its toJSON value first, if possible\n\n    if (value && value.toJSON && typeof value.toJSON === \"function\") {\n      value = value.toJSON();\n    } // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n    // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n\n\n    if (typeof replacer === \"function\") {\n      return replacer.call(holder, key, value);\n    } else if (replacer) {\n      if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n        return value;\n      } else {\n        return undefined;\n      }\n    } else {\n      return value;\n    }\n  };\n\n  function isWordChar(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '_' || c === '$';\n  }\n\n  function isWordStart(c) {\n    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '_' || c === '$';\n  }\n\n  function isWord(key) {\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (!isWordStart(key[0])) {\n      return false;\n    }\n\n    var i = 1,\n        length = key.length;\n\n    while (i < length) {\n      if (!isWordChar(key[i])) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  } // export for use in tests\n\n\n  JSON5.isWord = isWord; // polyfills\n\n  function isArray(obj) {\n    if (Array.isArray) {\n      return Array.isArray(obj);\n    } else {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n  }\n\n  function isDate(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n  }\n\n  var objStack = [];\n\n  function checkForCircular(obj) {\n    for (var i = 0; i < objStack.length; i++) {\n      if (objStack[i] === obj) {\n        throw new TypeError(\"Converting circular structure to JSON\");\n      }\n    }\n  }\n\n  function makeIndent(str, num, noNewLine) {\n    if (!str) {\n      return \"\";\n    } // indentation no more than 10 chars\n\n\n    if (str.length > 10) {\n      str = str.substring(0, 10);\n    }\n\n    var indent = noNewLine ? \"\" : \"\\n\";\n\n    for (var i = 0; i < num; i++) {\n      indent += str;\n    }\n\n    return indent;\n  }\n\n  var indentStr;\n\n  if (space) {\n    if (typeof space === \"string\") {\n      indentStr = space;\n    } else if (typeof space === \"number\" && space >= 0) {\n      indentStr = makeIndent(\" \", space, true);\n    } else {// ignore space parameter\n    }\n  } // Copied from Crokford's implementation of JSON\n  // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n  // Begin\n\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      meta = {\n    // table of character substitutions\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  function escapeString(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n      var c = meta[a];\n      return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n  } // End\n\n\n  function internalStringify(holder, key, isTopLevel) {\n    var buffer, res; // Replace the value, if necessary\n\n    var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n    if (obj_part && !isDate(obj_part)) {\n      // unbox objects\n      // don't unbox dates, since will turn it into number\n      obj_part = obj_part.valueOf();\n    }\n\n    switch (typeof obj_part) {\n      case \"boolean\":\n        return obj_part.toString();\n\n      case \"number\":\n        if (isNaN(obj_part) || !isFinite(obj_part)) {\n          return \"null\";\n        }\n\n        return obj_part.toString();\n\n      case \"string\":\n        return escapeString(obj_part.toString());\n\n      case \"object\":\n        if (obj_part === null) {\n          return \"null\";\n        } else if (isArray(obj_part)) {\n          checkForCircular(obj_part);\n          buffer = \"[\";\n          objStack.push(obj_part);\n\n          for (var i = 0; i < obj_part.length; i++) {\n            res = internalStringify(obj_part, i, false);\n            buffer += makeIndent(indentStr, objStack.length);\n\n            if (res === null || typeof res === \"undefined\") {\n              buffer += \"null\";\n            } else {\n              buffer += res;\n            }\n\n            if (i < obj_part.length - 1) {\n              buffer += \",\";\n            } else if (indentStr) {\n              buffer += \"\\n\";\n            }\n          }\n\n          objStack.pop();\n\n          if (obj_part.length) {\n            buffer += makeIndent(indentStr, objStack.length, true);\n          }\n\n          buffer += \"]\";\n        } else {\n          checkForCircular(obj_part);\n          buffer = \"{\";\n          var nonEmpty = false;\n          objStack.push(obj_part);\n\n          for (var prop in obj_part) {\n            if (obj_part.hasOwnProperty(prop)) {\n              var value = internalStringify(obj_part, prop, false);\n              isTopLevel = false;\n\n              if (typeof value !== \"undefined\" && value !== null) {\n                buffer += makeIndent(indentStr, objStack.length);\n                nonEmpty = true;\n                key = isWord(prop) ? prop : escapeString(prop);\n                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n              }\n            }\n          }\n\n          objStack.pop();\n\n          if (nonEmpty) {\n            buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + \"}\";\n          } else {\n            buffer = '{}';\n          }\n        }\n\n        return buffer;\n\n      default:\n        // functions and undefined should be ignored\n        return undefined;\n    }\n  } // special case...when undefined is used inside of\n  // a compound object/array, return null.\n  // but when top-level, return undefined\n\n\n  var topLevelHolder = {\n    \"\": obj\n  };\n\n  if (obj === undefined) {\n    return getReplacedValueOrUndefined(topLevelHolder, '', true);\n  }\n\n  return internalStringify(topLevelHolder, '', true);\n};","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/babel-core/node_modules/json5/lib/json5.js"],"names":["JSON5","exports","parse","at","lineNumber","columnNumber","ch","escapee","b","f","n","r","t","ws","text","renderChar","chr","error","m","SyntaxError","message","JSON","stringify","substring","next","c","charAt","peek","identifier","key","number","sign","string","base","word","isNaN","isFinite","hex","i","delim","uffff","parseInt","String","fromCharCode","inlineComment","blockComment","comment","white","indexOf","Infinity","NaN","value","array","push","object","source","reviver","result","walk","holder","k","v","Object","prototype","hasOwnProperty","call","undefined","obj","replacer","space","isArray","Error","getReplacedValueOrUndefined","isTopLevel","toJSON","isWordChar","isWordStart","isWord","length","Array","toString","isDate","objStack","checkForCircular","TypeError","makeIndent","str","num","noNewLine","indent","indentStr","cx","escapable","meta","escapeString","lastIndex","test","replace","a","charCodeAt","slice","internalStringify","buffer","res","obj_part","valueOf","pop","nonEmpty","prop","topLevelHolder"],"mappings":"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","sourcesContent":["// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\nvar JSON5 = (typeof exports === 'object' ? exports : {});\n\nJSON5.parse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON5 text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON5 parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,           // The index of the current character\n        lineNumber,   // The current line number\n        columnNumber, // The current column number\n        ch,           // The current character\n        escapee = {\n            \"'\":  \"'\",\n            '\"':  '\"',\n            '\\\\': '\\\\',\n            '/':  '/',\n            '\\n': '',       // Replace escaped newlines in strings w/ empty string\n            b:    '\\b',\n            f:    '\\f',\n            n:    '\\n',\n            r:    '\\r',\n            t:    '\\t'\n        },\n        ws = [\n            ' ',\n            '\\t',\n            '\\r',\n            '\\n',\n            '\\v',\n            '\\f',\n            '\\xA0',\n            '\\uFEFF'\n        ],\n        text,\n\n        renderChar = function (chr) {\n            return chr === '' ? 'EOF' : \"'\" + chr + \"'\";\n        },\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            var error = new SyntaxError();\n            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n            error.message = m + \" at line \" + lineNumber + \" column \" + columnNumber + \" of the JSON5 data. Still to read: \" + JSON.stringify(text.substring(at - 1, at + 19));\n            error.at = at;\n            // These two property names have been chosen to agree with the ones in Gecko, the only popular\n            // environment which seems to supply this info on JSON.parse\n            error.lineNumber = lineNumber;\n            error.columnNumber = columnNumber;\n            throw error;\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected \" + renderChar(c) + \" instead of \" + renderChar(ch));\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at++;\n            columnNumber++;\n            if (ch === '\\n' || ch === '\\r' && peek() !== '\\n') {\n                lineNumber++;\n                columnNumber = 0;\n            }\n            return ch;\n        },\n\n        peek = function () {\n\n// Get the next character without consuming it or\n// assigning it to the ch varaible.\n\n            return text.charAt(at);\n        },\n\n        identifier = function () {\n\n// Parse an identifier. Normally, reserved words are disallowed here, but we\n// only use this for unquoted object keys, where reserved words are allowed,\n// so we don't check for those here. References:\n// - http://es5.github.com/#x7.6\n// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n// TODO Identifiers can have Unicode \"letters\" in them; add support for those.\n\n            var key = ch;\n\n            // Identifiers must start with a letter, _ or $.\n            if ((ch !== '_' && ch !== '$') &&\n                    (ch < 'a' || ch > 'z') &&\n                    (ch < 'A' || ch > 'Z')) {\n                error(\"Bad identifier as unquoted key\");\n            }\n\n            // Subsequent characters can contain digits.\n            while (next() && (\n                    ch === '_' || ch === '$' ||\n                    (ch >= 'a' && ch <= 'z') ||\n                    (ch >= 'A' && ch <= 'Z') ||\n                    (ch >= '0' && ch <= '9'))) {\n                key += ch;\n            }\n\n            return key;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                sign = '',\n                string = '',\n                base = 10;\n\n            if (ch === '-' || ch === '+') {\n                sign = ch;\n                next(ch);\n            }\n\n            // support for Infinity (could tweak to allow other words):\n            if (ch === 'I') {\n                number = word();\n                if (typeof number !== 'number' || isNaN(number)) {\n                    error('Unexpected word for number');\n                }\n                return (sign === '-') ? -number : number;\n            }\n\n            // support for NaN\n            if (ch === 'N' ) {\n              number = word();\n              if (!isNaN(number)) {\n                error('expected word to be NaN');\n              }\n              // ignore sign as -NaN also is NaN\n              return number;\n            }\n\n            if (ch === '0') {\n                string += ch;\n                next();\n                if (ch === 'x' || ch === 'X') {\n                    string += ch;\n                    next();\n                    base = 16;\n                } else if (ch >= '0' && ch <= '9') {\n                    error('Octal literal');\n                }\n            }\n\n            switch (base) {\n            case 10:\n                while (ch >= '0' && ch <= '9' ) {\n                    string += ch;\n                    next();\n                }\n                if (ch === '.') {\n                    string += '.';\n                    while (next() && ch >= '0' && ch <= '9') {\n                        string += ch;\n                    }\n                }\n                if (ch === 'e' || ch === 'E') {\n                    string += ch;\n                    next();\n                    if (ch === '-' || ch === '+') {\n                        string += ch;\n                        next();\n                    }\n                    while (ch >= '0' && ch <= '9') {\n                        string += ch;\n                        next();\n                    }\n                }\n                break;\n            case 16:\n                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n                    string += ch;\n                    next();\n                }\n                break;\n            }\n\n            if(sign === '-') {\n                number = -string;\n            } else {\n                number = +string;\n            }\n\n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                delim,      // double quote or single quote\n                uffff;\n\n// When parsing for string values, we must look for ' or \" and \\ characters.\n\n            if (ch === '\"' || ch === \"'\") {\n                delim = ch;\n                while (next()) {\n                    if (ch === delim) {\n                        next();\n                        return string;\n                    } else if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (ch === '\\r') {\n                            if (peek() === '\\n') {\n                                next();\n                            }\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else if (ch === '\\n') {\n                        // unescaped newlines are invalid; see:\n                        // https://github.com/aseemk/json5/issues/24\n                        // TODO this feels special-cased; are there other\n                        // invalid unescaped chars?\n                        break;\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        inlineComment = function () {\n\n// Skip an inline comment, assuming this is one. The current character should\n// be the second / character in the // pair that begins this inline comment.\n// To finish the inline comment, we look for a newline or the end of the text.\n\n            if (ch !== '/') {\n                error(\"Not an inline comment\");\n            }\n\n            do {\n                next();\n                if (ch === '\\n' || ch === '\\r') {\n                    next();\n                    return;\n                }\n            } while (ch);\n        },\n\n        blockComment = function () {\n\n// Skip a block comment, assuming this is one. The current character should be\n// the * character in the /* pair that begins this block comment.\n// To finish the block comment, we look for an ending */ pair of characters,\n// but we also watch for the end of text before the comment is terminated.\n\n            if (ch !== '*') {\n                error(\"Not a block comment\");\n            }\n\n            do {\n                next();\n                while (ch === '*') {\n                    next('*');\n                    if (ch === '/') {\n                        next('/');\n                        return;\n                    }\n                }\n            } while (ch);\n\n            error(\"Unterminated block comment\");\n        },\n\n        comment = function () {\n\n// Skip a comment, whether inline or block-level, assuming this is one.\n// Comments always begin with a / character.\n\n            if (ch !== '/') {\n                error(\"Not a comment\");\n            }\n\n            next('/');\n\n            if (ch === '/') {\n                inlineComment();\n            } else if (ch === '*') {\n                blockComment();\n            } else {\n                error(\"Unrecognized comment\");\n            }\n        },\n\n        white = function () {\n\n// Skip whitespace and comments.\n// Note that we're detecting comments by only a single / character.\n// This works since regular expressions are not valid JSON(5), but this will\n// break if there are other valid values that begin with a / character!\n\n            while (ch) {\n                if (ch === '/') {\n                    comment();\n                } else if (ws.indexOf(ch) >= 0) {\n                    next();\n                } else {\n                    return;\n                }\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            case 'I':\n                next('I');\n                next('n');\n                next('f');\n                next('i');\n                next('n');\n                next('i');\n                next('t');\n                next('y');\n                return Infinity;\n            case 'N':\n              next( 'N' );\n              next( 'a' );\n              next( 'N' );\n              return NaN;\n            }\n            error(\"Unexpected \" + renderChar(ch));\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                while (ch) {\n                    if (ch === ']') {\n                        next(']');\n                        return array;   // Potentially empty array\n                    }\n                    // ES5 allows omitting elements in arrays, e.g. [,] and\n                    // [,null]. We don't allow this in JSON5.\n                    if (ch === ',') {\n                        error(\"Missing array element\");\n                    } else {\n                        array.push(value());\n                    }\n                    white();\n                    // If there's no comma after this value, this needs to\n                    // be the end of the array.\n                    if (ch !== ',') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                while (ch) {\n                    if (ch === '}') {\n                        next('}');\n                        return object;   // Potentially empty object\n                    }\n\n                    // Keys can be unquoted. If they are, they need to be\n                    // valid JS identifiers.\n                    if (ch === '\"' || ch === \"'\") {\n                        key = string();\n                    } else {\n                        key = identifier();\n                    }\n\n                    white();\n                    next(':');\n                    object[key] = value();\n                    white();\n                    // If there's no comma after this pair, this needs to be\n                    // the end of the object.\n                    if (ch !== ',') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n        case \"'\":\n            return string();\n        case '-':\n        case '+':\n        case '.':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = String(source);\n        at = 0;\n        lineNumber = 1;\n        columnNumber = 1;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return typeof reviver === 'function' ? (function walk(holder, key) {\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }({'': result}, '')) : result;\n    };\n}());\n\n// JSON5 stringify will not quote keys where appropriate\nJSON5.stringify = function (obj, replacer, space) {\n    if (replacer && (typeof(replacer) !== \"function\" && !isArray(replacer))) {\n        throw new Error('Replacer must be a function or an array');\n    }\n    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {\n        var value = holder[key];\n\n        // Replace the value with its toJSON value first, if possible\n        if (value && value.toJSON && typeof value.toJSON === \"function\") {\n            value = value.toJSON();\n        }\n\n        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n        if (typeof(replacer) === \"function\") {\n            return replacer.call(holder, key, value);\n        } else if(replacer) {\n            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n                return value;\n            } else {\n                return undefined;\n            }\n        } else {\n            return value;\n        }\n    };\n\n    function isWordChar(c) {\n        return (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c >= '0' && c <= '9') ||\n            c === '_' || c === '$';\n    }\n\n    function isWordStart(c) {\n        return (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            c === '_' || c === '$';\n    }\n\n    function isWord(key) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isWordStart(key[0])) {\n            return false;\n        }\n        var i = 1, length = key.length;\n        while (i < length) {\n            if (!isWordChar(key[i])) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n    // export for use in tests\n    JSON5.isWord = isWord;\n\n    // polyfills\n    function isArray(obj) {\n        if (Array.isArray) {\n            return Array.isArray(obj);\n        } else {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n    }\n\n    function isDate(obj) {\n        return Object.prototype.toString.call(obj) === '[object Date]';\n    }\n\n    var objStack = [];\n    function checkForCircular(obj) {\n        for (var i = 0; i < objStack.length; i++) {\n            if (objStack[i] === obj) {\n                throw new TypeError(\"Converting circular structure to JSON\");\n            }\n        }\n    }\n\n    function makeIndent(str, num, noNewLine) {\n        if (!str) {\n            return \"\";\n        }\n        // indentation no more than 10 chars\n        if (str.length > 10) {\n            str = str.substring(0, 10);\n        }\n\n        var indent = noNewLine ? \"\" : \"\\n\";\n        for (var i = 0; i < num; i++) {\n            indent += str;\n        }\n\n        return indent;\n    }\n\n    var indentStr;\n    if (space) {\n        if (typeof space === \"string\") {\n            indentStr = space;\n        } else if (typeof space === \"number\" && space >= 0) {\n            indentStr = makeIndent(\" \", space, true);\n        } else {\n            // ignore space parameter\n        }\n    }\n\n    // Copied from Crokford's implementation of JSON\n    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n    // Begin\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = { // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    };\n    function escapeString(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ?\n                c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n    // End\n\n    function internalStringify(holder, key, isTopLevel) {\n        var buffer, res;\n\n        // Replace the value, if necessary\n        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n        if (obj_part && !isDate(obj_part)) {\n            // unbox objects\n            // don't unbox dates, since will turn it into number\n            obj_part = obj_part.valueOf();\n        }\n        switch(typeof obj_part) {\n            case \"boolean\":\n                return obj_part.toString();\n\n            case \"number\":\n                if (isNaN(obj_part) || !isFinite(obj_part)) {\n                    return \"null\";\n                }\n                return obj_part.toString();\n\n            case \"string\":\n                return escapeString(obj_part.toString());\n\n            case \"object\":\n                if (obj_part === null) {\n                    return \"null\";\n                } else if (isArray(obj_part)) {\n                    checkForCircular(obj_part);\n                    buffer = \"[\";\n                    objStack.push(obj_part);\n\n                    for (var i = 0; i < obj_part.length; i++) {\n                        res = internalStringify(obj_part, i, false);\n                        buffer += makeIndent(indentStr, objStack.length);\n                        if (res === null || typeof res === \"undefined\") {\n                            buffer += \"null\";\n                        } else {\n                            buffer += res;\n                        }\n                        if (i < obj_part.length-1) {\n                            buffer += \",\";\n                        } else if (indentStr) {\n                            buffer += \"\\n\";\n                        }\n                    }\n                    objStack.pop();\n                    if (obj_part.length) {\n                        buffer += makeIndent(indentStr, objStack.length, true)\n                    }\n                    buffer += \"]\";\n                } else {\n                    checkForCircular(obj_part);\n                    buffer = \"{\";\n                    var nonEmpty = false;\n                    objStack.push(obj_part);\n                    for (var prop in obj_part) {\n                        if (obj_part.hasOwnProperty(prop)) {\n                            var value = internalStringify(obj_part, prop, false);\n                            isTopLevel = false;\n                            if (typeof value !== \"undefined\" && value !== null) {\n                                buffer += makeIndent(indentStr, objStack.length);\n                                nonEmpty = true;\n                                key = isWord(prop) ? prop : escapeString(prop);\n                                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n                            }\n                        }\n                    }\n                    objStack.pop();\n                    if (nonEmpty) {\n                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + \"}\";\n                    } else {\n                        buffer = '{}';\n                    }\n                }\n                return buffer;\n            default:\n                // functions and undefined should be ignored\n                return undefined;\n        }\n    }\n\n    // special case...when undefined is used inside of\n    // a compound object/array, return null.\n    // but when top-level, return undefined\n    var topLevelHolder = {\"\":obj};\n    if (obj === undefined) {\n        return getReplacedValueOrUndefined(topLevelHolder, '', true);\n    }\n    return internalStringify(topLevelHolder, '', true);\n};\n"]},"metadata":{},"sourceType":"script"}