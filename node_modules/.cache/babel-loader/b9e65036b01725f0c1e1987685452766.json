{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _maxSafeInteger = require(\"babel-runtime/core-js/number/max-safe-integer\");\n\nvar _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.toComputedKey = toComputedKey;\nexports.toSequenceExpression = toSequenceExpression;\nexports.toKeyAlias = toKeyAlias;\nexports.toIdentifier = toIdentifier;\nexports.toBindingIdentifierName = toBindingIdentifierName;\nexports.toStatement = toStatement;\nexports.toExpression = toExpression;\nexports.toBlock = toBlock;\nexports.valueToNode = valueToNode;\n\nvar _isPlainObject = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _isRegExp = require(\"lodash/isRegExp\");\n\nvar _isRegExp2 = _interopRequireDefault(_isRegExp);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction toComputedKey(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n\n  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var node = _ref;\n    ensureLastUndefined = false;\n\n    if (t.isExpression(node)) {\n      exprs.push(node);\n    } else if (t.isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (t.isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return;\n\n      for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var declar = _ref2;\n        var bindings = t.getBindingIdentifiers(declar);\n\n        for (var key in bindings) {\n          declars.push({\n            kind: node.kind,\n            id: bindings[key]\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(t.assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (t.isIfStatement(node)) {\n      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push(t.conditionalExpression(node.test, consequent, alternate));\n    } else if (t.isBlockStatement(node)) {\n      var body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if (t.isEmptyStatement(node)) {\n      ensureLastUndefined = true;\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return t.sequenceExpression(exprs);\n  }\n}\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!nodes || !nodes.length) return;\n  var declars = [];\n  var result = gatherSequenceExpressions(nodes, scope, declars);\n  if (!result) return;\n\n  for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var declar = _ref3;\n    scope.push(declar);\n  }\n\n  return result;\n}\n\nfunction toKeyAlias(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;\n  var alias = void 0;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (t.isIdentifier(key)) {\n    alias = key.name;\n  } else if (t.isStringLiteral(key)) {\n    alias = (0, _stringify2.default)(key.value);\n  } else {\n    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));\n  }\n\n  if (node.computed) {\n    alias = \"[\" + alias + \"]\";\n  }\n\n  if (node.static) {\n    alias = \"static:\" + alias;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= _maxSafeInteger2.default) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\nfunction toIdentifier(name) {\n  name = name + \"\";\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n  name = name.replace(/^[-0-9]+/, \"\");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!t.isValidIdentifier(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}\n\nfunction toBindingIdentifierName(name) {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\nfunction toStatement(node, ignore) {\n  if (t.isStatement(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType = void 0;\n\n  if (t.isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if (t.isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if (t.isAssignmentExpression(node)) {\n    return t.expressionStatement(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n  return node;\n}\n\nfunction toExpression(node) {\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  if (t.isExpression(node)) {\n    return node;\n  }\n\n  if (t.isClass(node)) {\n    node.type = \"ClassExpression\";\n  } else if (t.isFunction(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!t.isExpression(node)) {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n\n  return node;\n}\n\nfunction toBlock(node, parent) {\n  if (t.isBlockStatement(node)) {\n    return node;\n  }\n\n  if (t.isEmptyStatement(node)) {\n    node = [];\n  }\n\n  if (!Array.isArray(node)) {\n    if (!t.isStatement(node)) {\n      if (t.isFunction(parent)) {\n        node = t.returnStatement(node);\n      } else {\n        node = t.expressionStatement(node);\n      }\n    }\n\n    node = [node];\n  }\n\n  return t.blockStatement(node);\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return t.identifier(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return t.booleanLiteral(value);\n  }\n\n  if (value === null) {\n    return t.nullLiteral();\n  }\n\n  if (typeof value === \"string\") {\n    return t.stringLiteral(value);\n  }\n\n  if (typeof value === \"number\") {\n    return t.numericLiteral(value);\n  }\n\n  if ((0, _isRegExp2.default)(value)) {\n    var pattern = value.source;\n    var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return t.regExpLiteral(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return t.arrayExpression(value.map(t.valueToNode));\n  }\n\n  if ((0, _isPlainObject2.default)(value)) {\n    var props = [];\n\n    for (var key in value) {\n      var nodeKey = void 0;\n\n      if (t.isValidIdentifier(key)) {\n        nodeKey = t.identifier(key);\n      } else {\n        nodeKey = t.stringLiteral(key);\n      }\n\n      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));\n    }\n\n    return t.objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/babel-types/lib/converters.js"],"names":["exports","__esModule","_maxSafeInteger","require","_maxSafeInteger2","_interopRequireDefault","_stringify","_stringify2","_getIterator2","_getIterator3","toComputedKey","toSequenceExpression","toKeyAlias","toIdentifier","toBindingIdentifierName","toStatement","toExpression","toBlock","valueToNode","_isPlainObject","_isPlainObject2","_isRegExp","_isRegExp2","_index","t","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","default","node","arguments","length","undefined","property","computed","isIdentifier","stringLiteral","name","gatherSequenceExpressions","nodes","scope","declars","exprs","ensureLastUndefined","_iterator","_isArray","Array","isArray","_i","_ref","next","done","value","isExpression","push","isExpressionStatement","expression","isVariableDeclaration","kind","_iterator2","declarations","_isArray2","_i2","_ref2","declar","bindings","getBindingIdentifiers","id","init","assignmentExpression","isIfStatement","consequent","buildUndefinedNode","alternate","conditionalExpression","test","isBlockStatement","body","isEmptyStatement","sequenceExpression","result","_iterator3","_isArray3","_i3","_ref3","alias","increment","isStringLiteral","removePropertiesDeep","cloneDeep","static","uid","replace","match","c","toUpperCase","isValidIdentifier","ignore","isStatement","mustHaveId","newType","isClass","isFunction","isAssignmentExpression","expressionStatement","Error","type","parent","returnStatement","blockStatement","identifier","booleanLiteral","nullLiteral","numericLiteral","pattern","source","flags","toString","regExpLiteral","arrayExpression","map","props","nodeKey","objectProperty","objectExpression"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,eAAe,GAAGC,OAAO,CAAC,+CAAD,CAA7B;;AAEA,IAAIC,gBAAgB,GAAGC,sBAAsB,CAACH,eAAD,CAA7C;;AAEA,IAAII,UAAU,GAAGH,OAAO,CAAC,sCAAD,CAAxB;;AAEA,IAAII,WAAW,GAAGF,sBAAsB,CAACC,UAAD,CAAxC;;AAEA,IAAIE,aAAa,GAAGL,OAAO,CAAC,oCAAD,CAA3B;;AAEA,IAAIM,aAAa,GAAGJ,sBAAsB,CAACG,aAAD,CAA1C;;AAEAR,OAAO,CAACU,aAAR,GAAwBA,aAAxB;AACAV,OAAO,CAACW,oBAAR,GAA+BA,oBAA/B;AACAX,OAAO,CAACY,UAAR,GAAqBA,UAArB;AACAZ,OAAO,CAACa,YAAR,GAAuBA,YAAvB;AACAb,OAAO,CAACc,uBAAR,GAAkCA,uBAAlC;AACAd,OAAO,CAACe,WAAR,GAAsBA,WAAtB;AACAf,OAAO,CAACgB,YAAR,GAAuBA,YAAvB;AACAhB,OAAO,CAACiB,OAAR,GAAkBA,OAAlB;AACAjB,OAAO,CAACkB,WAAR,GAAsBA,WAAtB;;AAEA,IAAIC,cAAc,GAAGhB,OAAO,CAAC,sBAAD,CAA5B;;AAEA,IAAIiB,eAAe,GAAGf,sBAAsB,CAACc,cAAD,CAA5C;;AAEA,IAAIE,SAAS,GAAGlB,OAAO,CAAC,iBAAD,CAAvB;;AAEA,IAAImB,UAAU,GAAGjB,sBAAsB,CAACgB,SAAD,CAAvC;;AAEA,IAAIE,MAAM,GAAGpB,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIqB,CAAC,GAAGC,uBAAuB,CAACF,MAAD,CAA/B;;AAEA,SAASE,uBAAT,CAAiCC,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACzB,UAAf,EAA2B;AAAE,WAAOyB,GAAP;AAAa,GAA1C,MAAgD;AAAE,QAAIC,MAAM,GAAG,EAAb;;AAAiB,QAAID,GAAG,IAAI,IAAX,EAAiB;AAAE,WAAK,IAAIE,GAAT,IAAgBF,GAAhB,EAAqB;AAAE,YAAIG,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,GAArC,EAA0CE,GAA1C,CAAJ,EAAoDD,MAAM,CAACC,GAAD,CAAN,GAAcF,GAAG,CAACE,GAAD,CAAjB;AAAyB;AAAE;;AAACD,IAAAA,MAAM,CAACM,OAAP,GAAiBP,GAAjB;AAAsB,WAAOC,MAAP;AAAgB;AAAE;;AAE7Q,SAAStB,sBAAT,CAAgCqB,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACzB,UAAX,GAAwByB,GAAxB,GAA8B;AAAEO,IAAAA,OAAO,EAAEP;AAAX,GAArC;AAAwD;;AAE/F,SAAShB,aAAT,CAAuBwB,IAAvB,EAA6B;AAC3B,MAAIN,GAAG,GAAGO,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoED,IAAI,CAACN,GAAL,IAAYM,IAAI,CAACI,QAA/F;;AAEA,MAAI,CAACJ,IAAI,CAACK,QAAV,EAAoB;AAClB,QAAIf,CAAC,CAACgB,YAAF,CAAeZ,GAAf,CAAJ,EAAyBA,GAAG,GAAGJ,CAAC,CAACiB,aAAF,CAAgBb,GAAG,CAACc,IAApB,CAAN;AAC1B;;AACD,SAAOd,GAAP;AACD;;AAED,SAASe,yBAAT,CAAmCC,KAAnC,EAA0CC,KAA1C,EAAiDC,OAAjD,EAA0D;AACxD,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,mBAAmB,GAAG,IAA1B;;AAEA,OAAK,IAAIC,SAAS,GAAGL,KAAhB,EAAuBM,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcH,SAAd,CAAlC,EAA4DI,EAAE,GAAG,CAAjE,EAAoEJ,SAAS,GAAGC,QAAQ,GAAGD,SAAH,GAAe,CAAC,GAAGxC,aAAa,CAACwB,OAAlB,EAA2BgB,SAA3B,CAA5G,IAAqJ;AACnJ,QAAIK,IAAJ;;AAEA,QAAIJ,QAAJ,EAAc;AACZ,UAAIG,EAAE,IAAIJ,SAAS,CAACb,MAApB,EAA4B;AAC5BkB,MAAAA,IAAI,GAAGL,SAAS,CAACI,EAAE,EAAH,CAAhB;AACD,KAHD,MAGO;AACLA,MAAAA,EAAE,GAAGJ,SAAS,CAACM,IAAV,EAAL;AACA,UAAIF,EAAE,CAACG,IAAP,EAAa;AACbF,MAAAA,IAAI,GAAGD,EAAE,CAACI,KAAV;AACD;;AAED,QAAIvB,IAAI,GAAGoB,IAAX;AAEAN,IAAAA,mBAAmB,GAAG,KAAtB;;AAEA,QAAIxB,CAAC,CAACkC,YAAF,CAAexB,IAAf,CAAJ,EAA0B;AACxBa,MAAAA,KAAK,CAACY,IAAN,CAAWzB,IAAX;AACD,KAFD,MAEO,IAAIV,CAAC,CAACoC,qBAAF,CAAwB1B,IAAxB,CAAJ,EAAmC;AACxCa,MAAAA,KAAK,CAACY,IAAN,CAAWzB,IAAI,CAAC2B,UAAhB;AACD,KAFM,MAEA,IAAIrC,CAAC,CAACsC,qBAAF,CAAwB5B,IAAxB,CAAJ,EAAmC;AACxC,UAAIA,IAAI,CAAC6B,IAAL,KAAc,KAAlB,EAAyB;;AAEzB,WAAK,IAAIC,UAAU,GAAG9B,IAAI,CAAC+B,YAAtB,EAAoCC,SAAS,GAAGf,KAAK,CAACC,OAAN,CAAcY,UAAd,CAAhD,EAA2EG,GAAG,GAAG,CAAjF,EAAoFH,UAAU,GAAGE,SAAS,GAAGF,UAAH,GAAgB,CAAC,GAAGvD,aAAa,CAACwB,OAAlB,EAA2B+B,UAA3B,CAA/H,IAAyK;AACvK,YAAII,KAAJ;;AAEA,YAAIF,SAAJ,EAAe;AACb,cAAIC,GAAG,IAAIH,UAAU,CAAC5B,MAAtB,EAA8B;AAC9BgC,UAAAA,KAAK,GAAGJ,UAAU,CAACG,GAAG,EAAJ,CAAlB;AACD,SAHD,MAGO;AACLA,UAAAA,GAAG,GAAGH,UAAU,CAACT,IAAX,EAAN;AACA,cAAIY,GAAG,CAACX,IAAR,EAAc;AACdY,UAAAA,KAAK,GAAGD,GAAG,CAACV,KAAZ;AACD;;AAED,YAAIY,MAAM,GAAGD,KAAb;AAEA,YAAIE,QAAQ,GAAG9C,CAAC,CAAC+C,qBAAF,CAAwBF,MAAxB,CAAf;;AACA,aAAK,IAAIzC,GAAT,IAAgB0C,QAAhB,EAA0B;AACxBxB,UAAAA,OAAO,CAACa,IAAR,CAAa;AACXI,YAAAA,IAAI,EAAE7B,IAAI,CAAC6B,IADA;AAEXS,YAAAA,EAAE,EAAEF,QAAQ,CAAC1C,GAAD;AAFD,WAAb;AAID;;AAED,YAAIyC,MAAM,CAACI,IAAX,EAAiB;AACf1B,UAAAA,KAAK,CAACY,IAAN,CAAWnC,CAAC,CAACkD,oBAAF,CAAuB,GAAvB,EAA4BL,MAAM,CAACG,EAAnC,EAAuCH,MAAM,CAACI,IAA9C,CAAX;AACD;AACF;;AAEDzB,MAAAA,mBAAmB,GAAG,IAAtB;AACD,KA/BM,MA+BA,IAAIxB,CAAC,CAACmD,aAAF,CAAgBzC,IAAhB,CAAJ,EAA2B;AAChC,UAAI0C,UAAU,GAAG1C,IAAI,CAAC0C,UAAL,GAAkBjC,yBAAyB,CAAC,CAACT,IAAI,CAAC0C,UAAN,CAAD,EAAoB/B,KAApB,EAA2BC,OAA3B,CAA3C,GAAiFD,KAAK,CAACgC,kBAAN,EAAlG;AACA,UAAIC,SAAS,GAAG5C,IAAI,CAAC4C,SAAL,GAAiBnC,yBAAyB,CAAC,CAACT,IAAI,CAAC4C,SAAN,CAAD,EAAmBjC,KAAnB,EAA0BC,OAA1B,CAA1C,GAA+ED,KAAK,CAACgC,kBAAN,EAA/F;AACA,UAAI,CAACD,UAAD,IAAe,CAACE,SAApB,EAA+B;AAE/B/B,MAAAA,KAAK,CAACY,IAAN,CAAWnC,CAAC,CAACuD,qBAAF,CAAwB7C,IAAI,CAAC8C,IAA7B,EAAmCJ,UAAnC,EAA+CE,SAA/C,CAAX;AACD,KANM,MAMA,IAAItD,CAAC,CAACyD,gBAAF,CAAmB/C,IAAnB,CAAJ,EAA8B;AACnC,UAAIgD,IAAI,GAAGvC,yBAAyB,CAACT,IAAI,CAACgD,IAAN,EAAYrC,KAAZ,EAAmBC,OAAnB,CAApC;AACA,UAAI,CAACoC,IAAL,EAAW;AAEXnC,MAAAA,KAAK,CAACY,IAAN,CAAWuB,IAAX;AACD,KALM,MAKA,IAAI1D,CAAC,CAAC2D,gBAAF,CAAmBjD,IAAnB,CAAJ,EAA8B;AACnCc,MAAAA,mBAAmB,GAAG,IAAtB;AACD,KAFM,MAEA;AACL;AACD;AACF;;AAED,MAAIA,mBAAJ,EAAyB;AACvBD,IAAAA,KAAK,CAACY,IAAN,CAAWd,KAAK,CAACgC,kBAAN,EAAX;AACD;;AAED,MAAI9B,KAAK,CAACX,MAAN,KAAiB,CAArB,EAAwB;AACtB,WAAOW,KAAK,CAAC,CAAD,CAAZ;AACD,GAFD,MAEO;AACL,WAAOvB,CAAC,CAAC4D,kBAAF,CAAqBrC,KAArB,CAAP;AACD;AACF;;AAED,SAASpC,oBAAT,CAA8BiC,KAA9B,EAAqCC,KAArC,EAA4C;AAC1C,MAAI,CAACD,KAAD,IAAU,CAACA,KAAK,CAACR,MAArB,EAA6B;AAE7B,MAAIU,OAAO,GAAG,EAAd;AACA,MAAIuC,MAAM,GAAG1C,yBAAyB,CAACC,KAAD,EAAQC,KAAR,EAAeC,OAAf,CAAtC;AACA,MAAI,CAACuC,MAAL,EAAa;;AAEb,OAAK,IAAIC,UAAU,GAAGxC,OAAjB,EAA0ByC,SAAS,GAAGpC,KAAK,CAACC,OAAN,CAAckC,UAAd,CAAtC,EAAiEE,GAAG,GAAG,CAAvE,EAA0EF,UAAU,GAAGC,SAAS,GAAGD,UAAH,GAAgB,CAAC,GAAG7E,aAAa,CAACwB,OAAlB,EAA2BqD,UAA3B,CAArH,IAA+J;AAC7J,QAAIG,KAAJ;;AAEA,QAAIF,SAAJ,EAAe;AACb,UAAIC,GAAG,IAAIF,UAAU,CAAClD,MAAtB,EAA8B;AAC9BqD,MAAAA,KAAK,GAAGH,UAAU,CAACE,GAAG,EAAJ,CAAlB;AACD,KAHD,MAGO;AACLA,MAAAA,GAAG,GAAGF,UAAU,CAAC/B,IAAX,EAAN;AACA,UAAIiC,GAAG,CAAChC,IAAR,EAAc;AACdiC,MAAAA,KAAK,GAAGD,GAAG,CAAC/B,KAAZ;AACD;;AAED,QAAIY,MAAM,GAAGoB,KAAb;AAEA5C,IAAAA,KAAK,CAACc,IAAN,CAAWU,MAAX;AACD;;AAED,SAAOgB,MAAP;AACD;;AAED,SAASzE,UAAT,CAAoBsB,IAApB,EAA0B;AACxB,MAAIN,GAAG,GAAGO,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoED,IAAI,CAACN,GAAnF;AAEA,MAAI8D,KAAK,GAAG,KAAK,CAAjB;;AAEA,MAAIxD,IAAI,CAAC6B,IAAL,KAAc,QAAlB,EAA4B;AAC1B,WAAOnD,UAAU,CAAC+E,SAAX,KAAyB,EAAhC;AACD,GAFD,MAEO,IAAInE,CAAC,CAACgB,YAAF,CAAeZ,GAAf,CAAJ,EAAyB;AAC9B8D,IAAAA,KAAK,GAAG9D,GAAG,CAACc,IAAZ;AACD,GAFM,MAEA,IAAIlB,CAAC,CAACoE,eAAF,CAAkBhE,GAAlB,CAAJ,EAA4B;AACjC8D,IAAAA,KAAK,GAAG,CAAC,GAAGnF,WAAW,CAAC0B,OAAhB,EAAyBL,GAAG,CAAC6B,KAA7B,CAAR;AACD,GAFM,MAEA;AACLiC,IAAAA,KAAK,GAAG,CAAC,GAAGnF,WAAW,CAAC0B,OAAhB,EAAyBT,CAAC,CAACqE,oBAAF,CAAuBrE,CAAC,CAACsE,SAAF,CAAYlE,GAAZ,CAAvB,CAAzB,CAAR;AACD;;AAED,MAAIM,IAAI,CAACK,QAAT,EAAmB;AACjBmD,IAAAA,KAAK,GAAG,MAAMA,KAAN,GAAc,GAAtB;AACD;;AAED,MAAIxD,IAAI,CAAC6D,MAAT,EAAiB;AACfL,IAAAA,KAAK,GAAG,YAAYA,KAApB;AACD;;AAED,SAAOA,KAAP;AACD;;AAED9E,UAAU,CAACoF,GAAX,GAAiB,CAAjB;;AAEApF,UAAU,CAAC+E,SAAX,GAAuB,YAAY;AACjC,MAAI/E,UAAU,CAACoF,GAAX,IAAkB5F,gBAAgB,CAAC6B,OAAvC,EAAgD;AAC9C,WAAOrB,UAAU,CAACoF,GAAX,GAAiB,CAAxB;AACD,GAFD,MAEO;AACL,WAAOpF,UAAU,CAACoF,GAAX,EAAP;AACD;AACF,CAND;;AAQA,SAASnF,YAAT,CAAsB6B,IAAtB,EAA4B;AAC1BA,EAAAA,IAAI,GAAGA,IAAI,GAAG,EAAd;AAEAA,EAAAA,IAAI,GAAGA,IAAI,CAACuD,OAAL,CAAa,iBAAb,EAAgC,GAAhC,CAAP;AAEAvD,EAAAA,IAAI,GAAGA,IAAI,CAACuD,OAAL,CAAa,UAAb,EAAyB,EAAzB,CAAP;AAEAvD,EAAAA,IAAI,GAAGA,IAAI,CAACuD,OAAL,CAAa,aAAb,EAA4B,UAAUC,KAAV,EAAiBC,CAAjB,EAAoB;AACrD,WAAOA,CAAC,GAAGA,CAAC,CAACC,WAAF,EAAH,GAAqB,EAA7B;AACD,GAFM,CAAP;;AAIA,MAAI,CAAC5E,CAAC,CAAC6E,iBAAF,CAAoB3D,IAApB,CAAL,EAAgC;AAC9BA,IAAAA,IAAI,GAAG,MAAMA,IAAb;AACD;;AAED,SAAOA,IAAI,IAAI,GAAf;AACD;;AAED,SAAS5B,uBAAT,CAAiC4B,IAAjC,EAAuC;AACrCA,EAAAA,IAAI,GAAG7B,YAAY,CAAC6B,IAAD,CAAnB;AACA,MAAIA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,WAAhC,EAA6CA,IAAI,GAAG,MAAMA,IAAb;AAC7C,SAAOA,IAAP;AACD;;AAED,SAAS3B,WAAT,CAAqBmB,IAArB,EAA2BoE,MAA3B,EAAmC;AACjC,MAAI9E,CAAC,CAAC+E,WAAF,CAAcrE,IAAd,CAAJ,EAAyB;AACvB,WAAOA,IAAP;AACD;;AAED,MAAIsE,UAAU,GAAG,KAAjB;AACA,MAAIC,OAAO,GAAG,KAAK,CAAnB;;AAEA,MAAIjF,CAAC,CAACkF,OAAF,CAAUxE,IAAV,CAAJ,EAAqB;AACnBsE,IAAAA,UAAU,GAAG,IAAb;AACAC,IAAAA,OAAO,GAAG,kBAAV;AACD,GAHD,MAGO,IAAIjF,CAAC,CAACmF,UAAF,CAAazE,IAAb,CAAJ,EAAwB;AAC7BsE,IAAAA,UAAU,GAAG,IAAb;AACAC,IAAAA,OAAO,GAAG,qBAAV;AACD,GAHM,MAGA,IAAIjF,CAAC,CAACoF,sBAAF,CAAyB1E,IAAzB,CAAJ,EAAoC;AACzC,WAAOV,CAAC,CAACqF,mBAAF,CAAsB3E,IAAtB,CAAP;AACD;;AAED,MAAIsE,UAAU,IAAI,CAACtE,IAAI,CAACsC,EAAxB,EAA4B;AAC1BiC,IAAAA,OAAO,GAAG,KAAV;AACD;;AAED,MAAI,CAACA,OAAL,EAAc;AACZ,QAAIH,MAAJ,EAAY;AACV,aAAO,KAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIQ,KAAJ,CAAU,iBAAiB5E,IAAI,CAAC6E,IAAtB,GAA6B,iBAAvC,CAAN;AACD;AACF;;AAED7E,EAAAA,IAAI,CAAC6E,IAAL,GAAYN,OAAZ;AAEA,SAAOvE,IAAP;AACD;;AAED,SAASlB,YAAT,CAAsBkB,IAAtB,EAA4B;AAC1B,MAAIV,CAAC,CAACoC,qBAAF,CAAwB1B,IAAxB,CAAJ,EAAmC;AACjCA,IAAAA,IAAI,GAAGA,IAAI,CAAC2B,UAAZ;AACD;;AAED,MAAIrC,CAAC,CAACkC,YAAF,CAAexB,IAAf,CAAJ,EAA0B;AACxB,WAAOA,IAAP;AACD;;AAED,MAAIV,CAAC,CAACkF,OAAF,CAAUxE,IAAV,CAAJ,EAAqB;AACnBA,IAAAA,IAAI,CAAC6E,IAAL,GAAY,iBAAZ;AACD,GAFD,MAEO,IAAIvF,CAAC,CAACmF,UAAF,CAAazE,IAAb,CAAJ,EAAwB;AAC7BA,IAAAA,IAAI,CAAC6E,IAAL,GAAY,oBAAZ;AACD;;AAED,MAAI,CAACvF,CAAC,CAACkC,YAAF,CAAexB,IAAf,CAAL,EAA2B;AACzB,UAAM,IAAI4E,KAAJ,CAAU,iBAAiB5E,IAAI,CAAC6E,IAAtB,GAA6B,mBAAvC,CAAN;AACD;;AAED,SAAO7E,IAAP;AACD;;AAED,SAASjB,OAAT,CAAiBiB,IAAjB,EAAuB8E,MAAvB,EAA+B;AAC7B,MAAIxF,CAAC,CAACyD,gBAAF,CAAmB/C,IAAnB,CAAJ,EAA8B;AAC5B,WAAOA,IAAP;AACD;;AAED,MAAIV,CAAC,CAAC2D,gBAAF,CAAmBjD,IAAnB,CAAJ,EAA8B;AAC5BA,IAAAA,IAAI,GAAG,EAAP;AACD;;AAED,MAAI,CAACiB,KAAK,CAACC,OAAN,CAAclB,IAAd,CAAL,EAA0B;AACxB,QAAI,CAACV,CAAC,CAAC+E,WAAF,CAAcrE,IAAd,CAAL,EAA0B;AACxB,UAAIV,CAAC,CAACmF,UAAF,CAAaK,MAAb,CAAJ,EAA0B;AACxB9E,QAAAA,IAAI,GAAGV,CAAC,CAACyF,eAAF,CAAkB/E,IAAlB,CAAP;AACD,OAFD,MAEO;AACLA,QAAAA,IAAI,GAAGV,CAAC,CAACqF,mBAAF,CAAsB3E,IAAtB,CAAP;AACD;AACF;;AAEDA,IAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD;;AAED,SAAOV,CAAC,CAAC0F,cAAF,CAAiBhF,IAAjB,CAAP;AACD;;AAED,SAAShB,WAAT,CAAqBuC,KAArB,EAA4B;AAC1B,MAAIA,KAAK,KAAKpB,SAAd,EAAyB;AACvB,WAAOb,CAAC,CAAC2F,UAAF,CAAa,WAAb,CAAP;AACD;;AAED,MAAI1D,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAhC,EAAuC;AACrC,WAAOjC,CAAC,CAAC4F,cAAF,CAAiB3D,KAAjB,CAAP;AACD;;AAED,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAOjC,CAAC,CAAC6F,WAAF,EAAP;AACD;;AAED,MAAI,OAAO5D,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOjC,CAAC,CAACiB,aAAF,CAAgBgB,KAAhB,CAAP;AACD;;AAED,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOjC,CAAC,CAAC8F,cAAF,CAAiB7D,KAAjB,CAAP;AACD;;AAED,MAAI,CAAC,GAAGnC,UAAU,CAACW,OAAf,EAAwBwB,KAAxB,CAAJ,EAAoC;AAClC,QAAI8D,OAAO,GAAG9D,KAAK,CAAC+D,MAApB;AACA,QAAIC,KAAK,GAAGhE,KAAK,CAACiE,QAAN,GAAiBxB,KAAjB,CAAuB,cAAvB,EAAuC,CAAvC,CAAZ;AACA,WAAO1E,CAAC,CAACmG,aAAF,CAAgBJ,OAAhB,EAAyBE,KAAzB,CAAP;AACD;;AAED,MAAItE,KAAK,CAACC,OAAN,CAAcK,KAAd,CAAJ,EAA0B;AACxB,WAAOjC,CAAC,CAACoG,eAAF,CAAkBnE,KAAK,CAACoE,GAAN,CAAUrG,CAAC,CAACN,WAAZ,CAAlB,CAAP;AACD;;AAED,MAAI,CAAC,GAAGE,eAAe,CAACa,OAApB,EAA6BwB,KAA7B,CAAJ,EAAyC;AACvC,QAAIqE,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAIlG,GAAT,IAAgB6B,KAAhB,EAAuB;AACrB,UAAIsE,OAAO,GAAG,KAAK,CAAnB;;AACA,UAAIvG,CAAC,CAAC6E,iBAAF,CAAoBzE,GAApB,CAAJ,EAA8B;AAC5BmG,QAAAA,OAAO,GAAGvG,CAAC,CAAC2F,UAAF,CAAavF,GAAb,CAAV;AACD,OAFD,MAEO;AACLmG,QAAAA,OAAO,GAAGvG,CAAC,CAACiB,aAAF,CAAgBb,GAAhB,CAAV;AACD;;AACDkG,MAAAA,KAAK,CAACnE,IAAN,CAAWnC,CAAC,CAACwG,cAAF,CAAiBD,OAAjB,EAA0BvG,CAAC,CAACN,WAAF,CAAcuC,KAAK,CAAC7B,GAAD,CAAnB,CAA1B,CAAX;AACD;;AACD,WAAOJ,CAAC,CAACyG,gBAAF,CAAmBH,KAAnB,CAAP;AACD;;AAED,QAAM,IAAIhB,KAAJ,CAAU,+CAAV,CAAN;AACD","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _maxSafeInteger = require(\"babel-runtime/core-js/number/max-safe-integer\");\n\nvar _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.toComputedKey = toComputedKey;\nexports.toSequenceExpression = toSequenceExpression;\nexports.toKeyAlias = toKeyAlias;\nexports.toIdentifier = toIdentifier;\nexports.toBindingIdentifierName = toBindingIdentifierName;\nexports.toStatement = toStatement;\nexports.toExpression = toExpression;\nexports.toBlock = toBlock;\nexports.valueToNode = valueToNode;\n\nvar _isPlainObject = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _isRegExp = require(\"lodash/isRegExp\");\n\nvar _isRegExp2 = _interopRequireDefault(_isRegExp);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toComputedKey(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n  return key;\n}\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n\n  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var node = _ref;\n\n    ensureLastUndefined = false;\n\n    if (t.isExpression(node)) {\n      exprs.push(node);\n    } else if (t.isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (t.isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return;\n\n      for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var declar = _ref2;\n\n        var bindings = t.getBindingIdentifiers(declar);\n        for (var key in bindings) {\n          declars.push({\n            kind: node.kind,\n            id: bindings[key]\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(t.assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (t.isIfStatement(node)) {\n      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n\n      exprs.push(t.conditionalExpression(node.test, consequent, alternate));\n    } else if (t.isBlockStatement(node)) {\n      var body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n\n      exprs.push(body);\n    } else if (t.isEmptyStatement(node)) {\n      ensureLastUndefined = true;\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return t.sequenceExpression(exprs);\n  }\n}\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!nodes || !nodes.length) return;\n\n  var declars = [];\n  var result = gatherSequenceExpressions(nodes, scope, declars);\n  if (!result) return;\n\n  for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var declar = _ref3;\n\n    scope.push(declar);\n  }\n\n  return result;\n}\n\nfunction toKeyAlias(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;\n\n  var alias = void 0;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (t.isIdentifier(key)) {\n    alias = key.name;\n  } else if (t.isStringLiteral(key)) {\n    alias = (0, _stringify2.default)(key.value);\n  } else {\n    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));\n  }\n\n  if (node.computed) {\n    alias = \"[\" + alias + \"]\";\n  }\n\n  if (node.static) {\n    alias = \"static:\" + alias;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= _maxSafeInteger2.default) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\nfunction toIdentifier(name) {\n  name = name + \"\";\n\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!t.isValidIdentifier(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}\n\nfunction toBindingIdentifierName(name) {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\nfunction toStatement(node, ignore) {\n  if (t.isStatement(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType = void 0;\n\n  if (t.isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if (t.isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if (t.isAssignmentExpression(node)) {\n    return t.expressionStatement(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n\n  return node;\n}\n\nfunction toExpression(node) {\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  if (t.isExpression(node)) {\n    return node;\n  }\n\n  if (t.isClass(node)) {\n    node.type = \"ClassExpression\";\n  } else if (t.isFunction(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!t.isExpression(node)) {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n\n  return node;\n}\n\nfunction toBlock(node, parent) {\n  if (t.isBlockStatement(node)) {\n    return node;\n  }\n\n  if (t.isEmptyStatement(node)) {\n    node = [];\n  }\n\n  if (!Array.isArray(node)) {\n    if (!t.isStatement(node)) {\n      if (t.isFunction(parent)) {\n        node = t.returnStatement(node);\n      } else {\n        node = t.expressionStatement(node);\n      }\n    }\n\n    node = [node];\n  }\n\n  return t.blockStatement(node);\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return t.identifier(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return t.booleanLiteral(value);\n  }\n\n  if (value === null) {\n    return t.nullLiteral();\n  }\n\n  if (typeof value === \"string\") {\n    return t.stringLiteral(value);\n  }\n\n  if (typeof value === \"number\") {\n    return t.numericLiteral(value);\n  }\n\n  if ((0, _isRegExp2.default)(value)) {\n    var pattern = value.source;\n    var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return t.regExpLiteral(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return t.arrayExpression(value.map(t.valueToNode));\n  }\n\n  if ((0, _isPlainObject2.default)(value)) {\n    var props = [];\n    for (var key in value) {\n      var nodeKey = void 0;\n      if (t.isValidIdentifier(key)) {\n        nodeKey = t.identifier(key);\n      } else {\n        nodeKey = t.stringLiteral(key);\n      }\n      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));\n    }\n    return t.objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}"]},"metadata":{},"sourceType":"script"}