{"ast":null,"code":"\"use strict\";\n\nvar _map = require(\"lodash/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction crawl(node) {\n  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (t.isMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nexports.nodes = {\n  AssignmentExpression: function AssignmentExpression(node) {\n    var state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n  SwitchCase: function SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node\n    };\n  },\n  LogicalExpression: function LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n  Literal: function Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n  CallExpression: function CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(node) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      var enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        var state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n  IfStatement: function IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n};\n\nexports.nodes.ObjectProperty = exports.nodes.ObjectTypeProperty = exports.nodes.ObjectMethod = exports.nodes.SpreadProperty = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nexports.list = {\n  VariableDeclaration: function VariableDeclaration(node) {\n    return (0, _map2.default)(node.declarations, \"init\");\n  },\n  ArrayExpression: function ArrayExpression(node) {\n    return node.elements;\n  },\n  ObjectExpression: function ObjectExpression(node) {\n    return node.properties;\n  }\n};\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  var type = _ref[0],\n      amounts = _ref[1];\n\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    exports.nodes[type] = function () {\n      return amounts;\n    };\n  });\n});","map":{"version":3,"sources":["D:/Python files/Start Django/blog_tube/frontend/blog_tube/node_modules/babel-generator/lib/node/whitespace.js"],"names":["_map","require","_map2","_interopRequireDefault","_babelTypes","t","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","default","crawl","node","state","arguments","length","undefined","isMemberExpression","object","computed","property","isBinary","isAssignmentExpression","left","right","isCallExpression","hasCall","callee","isFunction","hasFunction","isIdentifier","hasHelper","isHelper","name","isType","isLiteral","isObjectExpression","isArrayExpression","exports","nodes","AssignmentExpression","before","after","SwitchCase","parent","consequent","cases","LogicalExpression","Literal","value","CallExpression","VariableDeclaration","i","declarations","declar","enabled","id","init","IfStatement","isBlockStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","SpreadProperty","properties","list","ArrayExpression","elements","ObjectExpression","forEach","_ref","type","amounts","concat","FLIPPED_ALIAS_KEYS"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _map = require(\"lodash/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction crawl(node) {\n  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (t.isMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nexports.nodes = {\n  AssignmentExpression: function AssignmentExpression(node) {\n    var state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n  SwitchCase: function SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node\n    };\n  },\n  LogicalExpression: function LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n  Literal: function Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n  CallExpression: function CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(node) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n\n      var enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled) {\n        var state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n  IfStatement: function IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n};\n\nexports.nodes.ObjectProperty = exports.nodes.ObjectTypeProperty = exports.nodes.ObjectMethod = exports.nodes.SpreadProperty = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nexports.list = {\n  VariableDeclaration: function VariableDeclaration(node) {\n    return (0, _map2.default)(node.declarations, \"init\");\n  },\n  ArrayExpression: function ArrayExpression(node) {\n    return node.elements;\n  },\n  ObjectExpression: function ObjectExpression(node) {\n    return node.properties;\n  }\n};\n\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  var type = _ref[0],\n      amounts = _ref[1];\n\n  if (typeof amounts === \"boolean\") {\n    amounts = { after: amounts, before: amounts };\n  }\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    exports.nodes[type] = function () {\n      return amounts;\n    };\n  });\n});"]},"metadata":{},"sourceType":"script"}